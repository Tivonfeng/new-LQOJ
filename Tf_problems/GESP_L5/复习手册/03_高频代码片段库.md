# C++五级高频代码片段库

> 基于2023.9-2025.12共10套真题（250题）代码模式总结
>
> **适用对象**：GESP C++五级考生
> **目标**：掌握核心代码模式，快速读懂题目

---

## 目录

1. [链表操作类](#一链表操作类)
2. [递归与迭代类](#二递归与迭代类)
3. [排序算法类](#三排序算法类)
4. [筛法求素数类](#四筛法求素数类)
5. [二分查找类](#五二分查找类)
6. [贪心算法类](#六贪心算法类)
7. [分治算法类](#七分治算法类)
8. [高精度运算类](#八高精度运算类)
9. [欧几里得算法类](#九欧几里得算法类)
10. [综合应用类](#十综合应用类)

---

## 一、链表操作类

### 1.1 单链表结构

```cpp
struct Node {
    int data;
    Node* next;
    Node(int x) : data(x), next(nullptr) {}
};
```

### 1.2 双向链表结构

```cpp
struct DNode {
    int data;
    DNode* prev;
    DNode* next;
    DNode(int x) : data(x), prev(nullptr), next(nullptr) {}
};
```

### 1.3 循环链表结构

```cpp
struct CNode {
    int data;
    CNode* next;
    CNode(int x) : data(x), next(this) {}
};
```

### 1.4 单链表头插法

```cpp
void insertHead(Node*& head, int val) {
    Node* newNode = new Node(val);
    newNode->next = head;
    head = newNode;
}
```

### 1.5 单链表尾插法

```cpp
void insertTail(Node*& head, int val) {
    Node* newNode = new Node(val);
    if (!head) {
        head = newNode;
        return;
    }
    Node* p = head;
    while (p->next) p = p->next;
    p->next = newNode;
}
```

### 1.6 单链表删除（虚拟头节点）

```cpp
void deleteNode(Node*& head, int val) {
    Node dummy(0);
    dummy.next = head;
    Node* cur = &dummy;
    while (cur->next) {
        if (cur->next->data == val) {
            Node* del = cur->next;
            cur->next = del->next;
            delete del;
        } else {
            cur = cur->next;
        }
    }
    head = dummy.next;
}
```

### 1.7 双向链表插入

```cpp
void insertAfter(DNode* p, int val) {
    if (!p) return;
    DNode* newNode = new DNode(val);
    newNode->prev = p;
    newNode->next = p->next;
    if (p->next) p->next->prev = newNode;
    p->next = newNode;
}
```

### 1.8 双向链表删除

```cpp
void deleteDNode(DNode* p) {
    if (p->prev) p->prev->next = p->next;
    if (p->next) p->next->prev = p->prev;
    delete p;
}
```

### 1.9 循环链表遍历

```cpp
void printCircular(CNode* head) {
    if (!head) return;
    CNode* p = head;
    do {
        cout << p->data << " ";
        p = p->next;
    } while (p != head);
}
```

### 1.10 快慢指针检测环

```cpp
bool hasCycle(Node* head) {
    if (!head || !head->next) return false;
    Node* slow = head;
    Node* fast = head->next;
    while (fast && fast->next) {
        if (slow == fast) return true;
        slow = slow->next;
        fast = fast->next->next;
    }
    return false;
}
```

---

## 二、递归与迭代类

### 2.1 递归阶乘

```cpp
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

### 2.2 迭代阶乘

```cpp
int factorialIter(int n) {
    int result = 1;
    for (int i = 2; i <= n; i++)
        result *= i;
    return result;
}
```

### 2.3 递归斐波那契（低效）

```cpp
long long fibRec(int n) {
    if (n <= 1) return n;
    return fibRec(n - 1) + fibRec(n - 2);
}
```

### 2.4 迭代斐波那契（高效）

```cpp
long long fibIter(int n) {
    if (n <= 1) return n;
    long long a = 0, b = 1;
    for (int i = 2; i <= n; i++) {
        long long c = a + b;
        a = b;
        b = c;
    }
    return b;
}
```

### 2.5 记忆化斐波那契

```cpp
long long fibMemo(int n) {
    vector<long long> memo(n + 2, -1);
    memo[0] = 0;
    memo[1] = 1;
    for (int i = 2; i <= n; i++)
        memo[i] = memo[i - 1] + memo[i - 2];
    return memo[n];
}
```

### 2.6 递归反转链表

```cpp
Node* reverseRec(Node* head) {
    if (!head || !head->next) return head;
    Node* newHead = reverseRec(head->next);
    head->next->next = head;
    head->next = nullptr;
    return newHead;
}
```

### 2.7 迭代反转链表

```cpp
Node* reverseIter(Node* head) {
    Node* prev = nullptr;
    Node* curr = head;
    while (curr) {
        Node* next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
```

---

## 三、排序算法类

### 3.1 快速排序partition

```cpp
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}
```

### 3.2 快速排序完整版

```cpp
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

### 3.3 归并排序merge

```cpp
void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) temp[k++] = arr[i++];
        else temp[k++] = arr[j++];
    }
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    for (k = 0; k < temp.size(); k++)
        arr[left + k] = temp[k];
}
```

### 3.4 归并排序完整版

```cpp
void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
```

### 3.5 冒泡排序

```cpp
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1])
                swap(arr[j], arr[j + 1]);
        }
    }
}
```

### 3.6 插入排序

```cpp
void insertionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

---

## 四、筛法求素数类

### 4.1 埃氏筛

```cpp
vector<bool> sieve(int n) {
    vector<bool> is_prime(n + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i)
                is_prime[j] = false;
        }
    }
    return is_prime;
}
```

### 4.2 线性筛

```cpp
vector<int> linearSieve(int n) {
    vector<bool> is_prime(n + 1, true);
    vector<int> primes;
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) primes.push_back(i);
        for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {
            is_prime[i * primes[j]] = false;
            if (i % primes[j] == 0) break;
        }
    }
    return primes;
}
```

### 4.3 唯一分解定理

```cpp
vector<int> primeFactors(int n) {
    vector<int> factors;
    for (int i = 2; i * i <= n; i++) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) factors.push_back(n);
    return factors;
}
```

### 4.4 判断素数（埃氏筛优化）

```cpp
bool isPrime(int n) {
    if (n < 2) return false;
    if (n == 2 || n == 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    int i = 5, step = 4;
    while (i * i <= n) {
        if (n % i == 0) return false;
        i += step;
        step = 6 - step;
    }
    return true;
}
```

---

## 五、二分查找类

### 5.1 基础二分查找

```cpp
int binarySearch(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

### 5.2 查找左边界

```cpp
int lower_bound(vector<int>& arr, int x) {
    int l = 0, r = arr.size();
    while (l < r) {
        int mid = l + (r - l) / 2;
        if (arr[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

### 5.3 查找右边界

```cpp
int upper_bound(vector<int>& arr, int x) {
    int l = 0, r = arr.size();
    while (l < r) {
        int mid = l + (r - l + 1) / 2;
        if (arr[mid] <= x) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 5.4 二分求平方根

```cpp
double sqrtBinary(double n, double eps = 1e-10) {
    double left = 0, right = n;
    while (right - left > eps) {
        double mid = (left + right) / 2;
        if (mid * mid < n) left = mid;
        else right = mid;
    }
    return left;
}
```

### 5.5 有序矩阵二分查找

```cpp
int countLE(vector<vector<int>>& matrix, int x) {
    int n = matrix.size();
    int i = n - 1, j = 0, cnt = 0;
    while (i >= 0 && j < n) {
        if (matrix[i][j] <= x) {
            cnt += i + 1;
            j++;
        } else {
            i--;
        }
    }
    return cnt;
}
```

---

## 六、贪心算法类

### 6.1 硬币找零

```cpp
int coinChange(vector<int>& coins, int amount) {
    sort(coins.rbegin(), coins.rend());
    int count = 0;
    for (int coin : coins) {
        count += amount / coin;
        amount %= coin;
        if (amount == 0) break;
    }
    return count;
}
```

### 6.2 分饼干

```cpp
int maxChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int i = g.size() - 1, j = s.size() - 1, count = 0;
    while (i >= 0 && j >= 0) {
        if (s[j] >= g[i]) {
            count++;
            i--;
            j--;
        } else {
            i--;
        }
    }
    return count;
}
```

### 6.3 活动选择

```cpp
int activitySelection(vector<vector<int>>& activities) {
    sort(activities.begin(), activities.end(),
         [](auto& a, auto& b) { return a[1] < b[1]; });
    int count = 1;
    int lastEnd = activities[0][1];
    for (int i = 1; i < activities.size(); i++) {
        if (activities[i][0] >= lastEnd) {
            count++;
            lastEnd = activities[i][1];
        }
    }
    return count;
}
```

### 6.4 任务调度（最大利润）

```cpp
int maxProfit(vector<Task>& tasks) {
    sort(tasks.begin(), tasks.end(),
         [](auto& a, auto& b) { return a.profit > b.profit; });
    int maxTime = 0;
    for (auto& t : tasks) maxTime = max(maxTime, t.deadline);
    vector<bool> slot(maxTime + 1, false);
    int totalProfit = 0;
    for (auto& task : tasks) {
        for (int t = task.deadline; t >= 1; t--) {
            if (!slot[t]) {
                slot[t] = true;
                totalProfit += task.profit;
                break;
            }
        }
    }
    return totalProfit;
}
```

---

## 七、分治算法类

### 7.1 分治求最大值

```cpp
int findMax(vector<int>& arr, int left, int right) {
    if (left == right) return arr[left];
    int mid = left + (right - left) / 2;
    int leftMax = findMax(arr, left, mid);
    int rightMax = findMax(arr, mid + 1, right);
    return max(leftMax, rightMax);
}
```

### 7.2 分治求最小值

```cpp
int findMin(vector<int>& arr, int left, int right) {
    if (left == right) return arr[left];
    int mid = left + (right - left) / 2;
    int leftMin = findMin(arr, left, mid);
    int rightMin = findMin(arr, mid + 1, right);
    return min(leftMin, rightMin);
}
```

### 7.3 分治求最大子数组和

```cpp
int crossSum(vector<int>& nums, int left, int mid, int right) {
    int leftSum = INT_MIN, sum = 0;
    for (int i = mid; i >= left; i--) {
        sum += nums[i];
        leftSum = max(leftSum, sum);
    }
    sum = 0;
    int rightSum = INT_MIN;
    for (int i = mid + 1; i <= right; i++) {
        sum += nums[i];
        rightSum = max(rightSum, sum);
    }
    return leftSum + rightSum;
}

int maxSubArray(vector<int>& nums, int left, int right) {
    if (left == right) return nums[left];
    int mid = left + (right - left) / 2;
    int leftMax = maxSubArray(nums, left, mid);
    int rightMax = maxSubArray(nums, mid + 1, right);
    int crossMax = crossSum(nums, left, mid, right);
    return max({leftMax, rightMax, crossMax});
}
```

### 7.4 汉诺塔

```cpp
void hanoi(int n, char from, char to, char aux) {
    if (n == 1) {
        cout << from << " -> " << to << endl;
        return;
    }
    hanoi(n - 1, from, aux, to);
    cout << from << " -> " << to << endl;
    hanoi(n - 1, aux, to, from);
}
```

---

## 八、高精度运算类

### 8.1 高精度加法（低位在前）

```cpp
vector<int> add(vector<int> a, vector<int> b) {
    vector<int> c;
    int carry = 0;
    for (int i = 0; i < a.size() || i < b.size(); i++) {
        if (i < a.size()) carry += a[i];
        if (i < b.size()) carry += b[i];
        c.push_back(carry % 10);
        carry /= 10;
    }
    if (carry) c.push_back(carry);
    return c;
}
```

### 8.2 高精度减法（低位在前）

```cpp
vector<int> sub(vector<int> a, vector<int> b) {  // a >= b
    vector<int> c;
    int borrow = 0;
    for (int i = 0; i < a.size(); i++) {
        int digitA = a[i];
        int digitB = i < b.size() ? b[i] : 0;
        int diff = digitA - borrow - digitB;
        if (diff < 0) {
            diff += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        c.push_back(diff);
    }
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    return c;
}
```

### 8.3 高精度乘法

```cpp
vector<int> multiply(vector<int>& a, vector<int>& b) {
    vector<int> c(a.size() + b.size(), 0);
    for (int i = 0; i < a.size(); i++)
        for (int j = 0; j < b.size(); j++)
            c[i + j] += a[i] * b[j];
    
    int carry = 0;
    for (int i = 0; i < c.size(); i++) {
        c[i] += carry;
        carry = c[i] / 10;
        c[i] %= 10;
    }
    while (carry) {
        c.push_back(carry % 10);
        carry /= 10;
    }
    return c;
}
```

### 8.4 高精度除法

```cpp
vector<int> divide(vector<int> a, int b) {
    vector<int> c;
    int carry = 0;
    for (int i = a.size() - 10; i--); i >=  {
        carry = carry * 10 + a[i];
        c.push_back(carry / b);
        carry %= b;
    }
    reverse(c.begin(), c.end());
    while (c.size() > 1 && c.front() == 0) c.erase(c.begin());
    return c;
}
```

### 8.5 大整数+1

```cpp
vector<int> plusOne(vector<int>& digits) {
    for (int i = digits.size() - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i]++;
            return digits;
        }
        digits[i] = 0;
    }
    digits.insert(digits.begin(), 1);
    return digits;
}
```

---

## 九、欧几里得算法类

### 9.1 递归版GCD

```cpp
int gcdRec(int a, int b) {
    if (b == 0) return a;
    return gcdRec(b, a % b);
}
```

### 9.2 迭代版GCD

```cpp
int gcdIter(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

### 9.3 最小公倍数

```cpp
int lcm(int a, int b) {
    return a / gcdIter(a, b) * b;
}
```

### 9.4 扩展欧几里得

```cpp
int extgcd(int a, int b, int& x, int& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    int x1, y1;
    int g = extgcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return g;
}
```

---

## 十、综合应用类

### 10.1 判断完全数

```cpp
bool isPerfectNumber(int n) {
    if (n <= 1) return false;
    int sum = 1;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            sum += i;
            if (i != n / i) sum += n / i;
        }
    }
    return sum == n;
}
```

### 10.2 约瑟夫问题

```cpp
int josephus(int n, int k) {
    if (n == 1) return 0;
    if (k == 1) return n - 1;
    int res = josephus(n - 1, k);
    return (res + k) % n;
}
```

### 10.3 判断链表相交

```cpp
Node* getIntersection(Node* headA, Node* headB) {
    Node* pA = headA;
    Node* pB = headB;
    while (pA != pB) {
        pA = pA ? pA->next : headB;
        pB = pB ? pB->next : headA;
    }
    return pA;
}
```

### 10.4 链表排序（归并）

```cpp
Node* mergeTwoLists(Node* l1, Node* l2) {
    Node dummy(0);
    Node* cur = &dummy;
    while (l1 && l2) {
        if (l1->data < l2->data) {
            cur->next = l1;
            l1 = l1->next;
        } else {
            cur->next = l2;
            l2 = l2->next;
        }
        cur = cur->next;
    }
    cur->next = l1 ? l1 : l2;
    return dummy.next;
}
```

### 10.5 判断回文链表

```cpp
bool isPalindrome(Node* head) {
    if (!head || !head->next) return true;
    Node* slow = head;
    Node* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    Node* second = reverseIter(slow);
    Node* p1 = head;
    Node* p2 = second;
    while (p2) {
        if (p1->data != p2->data) return false;
        p1 = p1->next;
        p2 = p2->next;
    }
    return true;
}
```
