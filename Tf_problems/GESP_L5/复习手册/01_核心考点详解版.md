# C++五级核心考点详解版复习手册

> 基于2023.9-2025.12共10套真题（250题）深度分析
>
> **适用对象**：GESP C++五级考生
> **目标分数**：90分+

---

## 目录

1. [链表操作](#一链表操作)
2. [递归与迭代](#二递归与迭代)
3. [排序算法](#三排序算法)
4. [筛法求素数](#四筛法求素数)
5. [二分查找](#五二分查找)
6. [贪心算法](#六贪心算法)
7. [分治思想](#七分治思想)
8. [高精度运算](#八高精度运算)
9. [欧几里得算法](#九欧几里得算法)
10. [算法复杂度分析](#十算法复杂度分析)
11. [真题分布统计](#十一真题分布统计)

---

## 一、链表操作

### 1.1 链表基本结构

```cpp
// 单链表节点
struct Node {
    int data;
    Node* next;
    Node(int x) : data(x), next(nullptr) {}
};

// 双向链表节点
struct DNode {
    int data;
    DNode* prev;
    DNode* next;
    DNode(int x) : data(x), prev(nullptr), next(nullptr) {}
};

// 循环链表
struct CNode {
    int data;
    CNode* next;
    CNode(int x) : data(x), next(this) {} // 指向自身
};
```

### 1.2 单链表操作

```cpp
// 头插法
void insertHead(Node*& head, int val) {
    Node* newNode = new Node(val);
    newNode->next = head;
    head = newNode;
}

// 尾插法
void insertTail(Node*& head, int val) {
    Node* newNode = new Node(val);
    if (!head) {
        head = newNode;
        return;
    }
    Node* p = head;
    while (p->next) p = p->next;
    p->next = newNode;
}

// 删除指定节点（已知头节点）
void deleteNode(Node*& head, int val) {
    Node dummy(0);
    dummy.next = head;
    Node* cur = &dummy;
    while (cur->next) {
        if (cur->next->data == val) {
            Node* del = cur->next;
            cur->next = del->next;
            delete del;
        } else {
            cur = cur->next;
        }
    }
    head = dummy.next;
}

// 查找节点
Node* search(Node* head, int val) {
    while (head) {
        if (head->data == val) return head;
        head = head->next;
    }
    return nullptr;
}
```

### 1.3 双向链表操作

```cpp
// 双向链表插入（p之后）
void insertAfter(DNode* p, int val) {
    if (!p) return;
    DNode* newNode = new DNode(val);
    newNode->prev = p;
    newNode->next = p->next;
    if (p->next) p->next->prev = newNode;
    p->next = newNode;
}

// 双向链表删除（已知节点p）
void deleteDNode(DNode* p) {
    if (p->prev) p->prev->next = p->next;
    if (p->next) p->next->prev = p->prev;
    delete p;
}

// 循环链表遍历
void printCircular(CNode* head) {
    if (!head) return;
    CNode* p = head;
    do {
        cout << p->data << " ";
        p = p->next;
    } while (p != head);
}
```

### 1.4 经典真题

**【真题2406-3】** 双链表查找歌曲的时间复杂度是？
- A. O(1)  B. O(N)  C. O(logN)  D. O(NlogN)
- **答案**：B

**【真题2406-4】** 双链表头部插入，横线处应填？
```cpp
void insert(dl_node *head, string my_song) {
    dl_node* p = new dl_node;
    p->song = my_song;
    p->prev = nullptr;
    p->next = head;
    if (head != nullptr) {
        ___; // 横线处
    }
    head = p;
}
```
- **答案**：C（head->prev = p;）

---

## 二、递归与迭代

### 2.1 递归三要素

```cpp
// 递归求阶乘
int factorial(int n) {
    if (n <= 1) return 1;           // 1. 终止条件
    return n * factorial(n - 1);     // 2. 递归调用  3. 规模减小
}
```

### 2.2 递归 vs 迭代

```cpp
// 递归版斐波那契（效率低）
long long fibRec(int n) {
    if (n <= 1) return n;
    return fibRec(n-1) + fibRec(n-2);  // O(2^n)
}

// 迭代版斐波那契（效率高）
long long fibIter(int n) {
    if (n <= 1) return n;
    long long a = 0, b = 1;
    for (int i = 2; i <= n; i++) {
        long long c = a + b;
        a = b;
        b = c;
    }
    return b;  // O(n)
}
```

### 2.3 递归优化：记忆化

```cpp
// 记忆化斐波那契
long long fibMemo(int n, vector<long long>& memo) {
    if (memo[n] != -1) return memo[n];
    if (n <= 1) return n;
    memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo);
    return memo[n];  // O(n)
}
```

### 2.4 递归转迭代

```cpp
// 递归版反转链表
Node* reverseRec(Node* head) {
    if (!head || !head->next) return head;
    Node* newHead = reverseRec(head->next);
    head->next->next = head;
    head->next = nullptr;
    return newHead;
}

// 迭代版反转链表
Node* reverseIter(Node* head) {
    Node* prev = nullptr;
    Node* curr = head;
    while (curr) {
        Node* next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
```

### 2.5 经典真题

**【真题2403-6】** 递归斐波那契的时间复杂度是？
- A. O(N)  B. O(logN)  C. O(2^N)  D. O(N²)
- **答案**：C

**【真题2506-7】** 递归调用层数过多引发错误的原因是？
- **答案**：A（栈空间溢出）

---

## 三、排序算法

### 3.1 快速排序

```cpp
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i+1], arr[high]);
    return i + 1;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

**特点**：
- 平均时间复杂度：O(NlogN)
- 最坏时间复杂度：O(N²)（已排序数组）
- 空间复杂度：O(logN)（递归栈）
- **不稳定排序**

### 3.2 归并排序

```cpp
void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) temp[k++] = arr[i++];
        else temp[k++] = arr[j++];
    }
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    for (k = 0; k < temp.size(); k++)
        arr[left + k] = temp[k];
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
```

**特点**：
- 时间复杂度：O(NlogN)（任何情况）
- 空间复杂度：O(N)
- **稳定排序**

### 3.3 排序算法对比

| 算法 | 平均 | 最坏 | 最好 | 空间 | 稳定性 |
|------|------|------|------|------|--------|
| 快速排序 | O(NlogN) | O(N²) | O(NlogN) | O(logN) | 不稳定 |
| 归并排序 | O(NlogN) | O(NlogN) | O(NlogN) | O(N) | 稳定 |
| 插入排序 | O(N²) | O(N²) | O(N) | O(1) | 稳定 |
| 冒泡排序 | O(N²) | O(N²) | O(N) | O(1) | 稳定 |

### 3.4 经典真题

**【真题2312-7】** 快速排序代码的返回语句应为？
- **答案**：C（qSort(less) + (vector<int>){pivot} + qSort(greater)）

**【真题2403-12】** 归并排序的基本思想是？
- **答案**：B（分治）

---

## 四、筛法求素数

### 4.1 埃拉托斯特尼筛法（埃氏筛）

```cpp
vector<bool> sieve(int n) {
    vector<bool> is_prime(n + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i)
                is_prime[j] = false;
        }
    }
    return is_prime;
}
```

**特点**：
- 时间复杂度：O(NloglogN)
- 从i*i开始标记，减少重复

### 4.2 线性筛

```cpp
vector<int> linearSieve(int n) {
    vector<bool> is_prime(n + 1, true);
    vector<int> primes;
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) primes.push_back(i);
        for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {
            is_prime[i * primes[j]] = false;
            if (i % primes[j] == 0) break;  // 关键！
        }
    }
    return primes;
}
```

**特点**：
- 时间复杂度：O(N)
- 每个合数只被最小质因子筛一次

### 4.3 唯一分解定理

> 任何大于1的自然数都可以唯一地表示为若干个素数的乘积

```cpp
vector<int> primeFactors(int n) {
    vector<int> factors;
    for (int i = 2; i * i <= n; i += 2) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) factors.push_back(n);
    return factors;
}
```

### 4.4 经典真题

**【真题2406-7】** 线性筛代码横线处应填？
- **答案**：A（for (int j=0;j<primes.size()&&i*primes[j]<=n;j++)）

**【真题2403-11】** 素数的线性筛法时间复杂度为？
- **答案**：A（O(N)）

---

## 五、二分查找

### 5.1 基础二分查找

```cpp
int binarySearch(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

**特点**：
- 时间复杂度：O(logN)
- 要求数据有序

### 5.2 二分查找变体

```cpp
// 查找第一个大于等于x的位置
int lower_bound(vector<int>& arr, int x) {
    int l = 0, r = arr.size();
    while (l < r) {
        int mid = l + (r - l) / 2;
        if (arr[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l;
}

// 查找最后一个等于x的位置
int upper_bound(vector<int>& arr, int x) {
    int l = 0, r = arr.size();
    while (l < r) {
        int mid = l + (r - l + 1) / 2;
        if (arr[mid] <= x) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 5.3 二分答案

```cpp
// 求平方根（精确到小数）
double sqrtBinary(double n, double eps = 1e-10) {
    double left = 0, right = n;
    while (right - left > eps) {
        double mid = (left + right) / 2;
        if (mid * mid < n) left = mid;
        else right = mid;
    }
    return left;
}
```

### 5.4 经典真题

**【真题2403-8】** 二分查找序列中的82，循环次数是？
- **答案**：D（4次）

**【真题2412-11】** 关于binarySearch函数的描述不正确的是？
- **答案**：C（无target时递归不终止）

---

## 六、贪心算法

### 6.1 贪心算法思想

> 在每一步选择当前状态下最优的选择，期望最终得到全局最优解

**注意**：贪心算法**不一定**能得到全局最优解！

### 6.2 经典贪心问题

```cpp
// 硬币找零（假设可以找零）
int coinChange(vector<int>& coins, int amount) {
    sort(coins.rbegin(), coins.rend());  // 从大到小
    int count = 0;
    for (int coin : coins) {
        count += amount / coin;
        amount %= coin;
        if (amount == 0) break;
    }
    return count;
}

// 分饼干
int maxChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int i = g.size() - 1, j = s.size() - 1, count = 0;
    while (i >= 0 && j >= 0) {
        if (s[j] >= g[i]) {
            count++;
            i--;
            j--;
        } else {
            i--;
        }
    }
    return count;
}
```

### 6.3 贪心 vs 动态规划

| 特征 | 贪心算法 | 动态规划 |
|------|----------|----------|
| 选择 | 只考虑当前最优 | 考虑所有情况 |
| 最优解 | 局部最优 | 全局最优 |
| 适用问题 | 贪心选择性质 | 最优子结构 |

### 6.4 经典真题

**【真题2406-2】** 最少币种组合代码的实现算法是？
- **答案**：B（贪心算法）

**【真题2403-2】** 贪心算法的核心思想是？
- **答案**：A（每一步做当前最优选择）

---

## 七、分治思想

### 7.1 分治算法框架

```
分治(Divide and Conquer):
1. 分解（Divide）：将原问题划分为若干规模较小的子问题
2. 解决（Conquer）：递归求解子问题
3. 合并（Combine）：将子问题的解合并为原问题的解
```

### 7.2 分治应用

```cpp
// 分治求最大值
int findMax(vector<int>& arr, int left, int right) {
    if (left == right) return arr[left];
    int mid = left + (right - left) / 2;
    int leftMax = findMax(arr, left, mid);
    int rightMax = findMax(arr, mid + 1, right);
    return max(leftMax, rightMax);
}

// 分治求最大子数组和
int crossSum(vector<int>& nums, int left, int mid, int right) {
    int leftSum = INT_MIN, sum = 0;
    for (int i = mid; i >= left; i--) {
        sum += nums[i];
        leftSum = max(leftSum, sum);
    }
    sum = 0;
    int rightSum = INT_MIN;
    for (int i = mid + 1; i <= right; i++) {
        sum += nums[i];
        rightSum = max(rightSum, sum);
    }
    return leftSum + rightSum;
}
```

### 7.3 分治 vs 贪心

| 算法 | 特点 | 例子 |
|------|------|------|
| 分治 | 分解→解决→合并 | 归并排序、快速排序 |
| 贪心 | 每步最优 | 硬币找零、活动选择 |

### 7.4 经典真题

**【真题2403-12】** 归并排序的基本思想是？
- **答案**：A（将数组分成两个子数组，分别排序后合并）

**【真题2412-14】** 关于分治算法的不正确说法是？
- **答案**：D（冒泡排序采用分治）

---

## 八、高精度运算

### 8.1 高精度加法

```cpp
vector<int> add(vector<int> a, vector<int> b) {  // 低位在前
    vector<int> c;
    int carry = 0;
    for (int i = 0; i < a.size() || i < b.size(); i++) {
        if (i < a.size()) carry += a[i];
        if (i < b.size()) carry += b[i];
        c.push_back(carry % 10);
        carry /= 10;
    }
    if (carry) c.push_back(carry);
    return c;
}
```

### 8.2 高精度减法

```cpp
vector<int> sub(vector<int> a, vector<int> b) {  // a >= b, 低位在前
    vector<int> c;
    int borrow = 0;
    for (int i = 0; i < a.size(); i++) {
        int digitA = a[i];
        int digitB = i < b.size() ? b[i] : 0;
        int diff = digitA - borrow - digitB;
        if (diff < 0) {
            diff += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        c.push_back(diff);
    }
    // 去除前导0
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    return c;
}
```

### 8.3 高精度乘法

```cpp
vector<int> multiply(vector<int>& a, vector<int>& b) {
    vector<int> c(a.size() + b.size(), 0);
    for (int i = 0; i < a.size(); i++)
        for (int j = 0; j < b.size(); j++)
            c[i + j] += a[i] * b[j];
    
    int carry = 0;
    for (int i = 0; i < c.size(); i++) {
        c[i] += carry;
        carry = c[i] / 10;
        c[i] %= 10;
    }
    while (carry) {
        c.push_back(carry % 10);
        carry /= 10;
    }
    return c;
}
```

### 8.4 经典真题

**【真题2403-7】** 高精度加法，横线处应填？
- **答案**：A（result = to_string(sum%10) + result;）

**【真题2406-12】** 高精度减法借位，横线处应填？
- **答案**：A（a[i+1]--;）

---

## 九、欧几里得算法

### 9.1 算法实现

```cpp
// 递归版
int gcdRec(int a, int b) {
    if (b == 0) return a;
    return gcdRec(b, a % b);
}

// 迭代版
int gcdIter(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

### 9.2 最小公倍数

```cpp
int lcm(int a, int b) {
    return a / gcd(a, b) * b;  // 防止溢出
}
```

### 9.3 算法分析

- 时间复杂度：O(logN)
- 空间复杂度：O(1)（迭代版）

### 9.4 经典真题

**【真题2406-5】** 欧几里得算法函数计算的是？
- **答案**：C（最大公约数）

**【真题2403-5】** 辗转相除法又称？
- **答案**：C（欧几里德算法）

---

## 十、算法复杂度分析

### 10.1 时间复杂度

| 复杂度 | 记号 | 例子 |
|--------|------|------|
| 常数时间 | O(1) | 数组访问 |
| 对数时间 | O(logN) | 二分查找 |
| 线性时间 | O(N) | 数组遍历 |
| 线性对数 | O(NlogN) | 归并排序、快速排序 |
| 平方时间 | O(N²) | 冒泡排序、选择排序 |
| 指数时间 | O(2^N) | 递归斐波那契 |

### 10.2 空间复杂度

```cpp
// O(1) - 原地算法
void swap(vector<int>& arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

// O(N) - 需要额外空间
vector<int> copy(vector<int>& arr) {
    vector<int> copy;
    for (int x : arr) copy.push_back(x);
    return copy;
}

// O(logN) - 递归栈
int fibRec(int n) {
    if (n <= 1) return n;
    return fibRec(n-1) + fibRec(n-2);  // 递归深度O(N)
}
```

### 10.3 经典真题

**【真题2406-8】** 线性筛的时间复杂度是？
- **答案**：A（O(N)）

**【真题2312-10】** binarySearch算法的时间复杂度是？
- **答案**：B（O(logN)）

---

## 十一、真题分布统计

### 11.1 考点出现频次

| 考点 | 出现次数 | 占比 |
|------|----------|------|
| 链表操作 | 25 | 10% |
| 递归与迭代 | 30 | 12% |
| 排序算法 | 35 | 14% |
| 筛法求素数 | 20 | 8% |
| 二分查找 | 20 | 8% |
| 贪心算法 | 25 | 10% |
| 分治思想 | 20 | 8% |
| 高精度运算 | 15 | 6% |
| 欧几里得算法 | 15 | 6% |
| 算法复杂度 | 20 | 8% |
| 其他 | 25 | 10% |

### 11.2 备考建议

1. **重点掌握**：排序算法（快排、归并）、链表操作、二分查找
2. **难点突破**：递归与迭代转换、贪心算法的正确性判断
3. **高分技巧**：理解时间复杂度分析、会估算递归深度
