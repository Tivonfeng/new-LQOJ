# C++五级易错点避坑指南

> 基于2023.9-2025.12共10套真题（250题）高频陷阱总结
>
> **适用对象**：GESP C++五级考生
> **目标**：避开常见陷阱，稳定拿高分

---

## 目录

1. [链表操作陷阱](#一链表操作陷阱)
2. [递归与迭代陷阱](#二递归与迭代陷阱)
3. [排序算法陷阱](#三排序算法陷阱)
4. [筛法陷阱](#四筛法陷阱)
5. [二分查找陷阱](#五二分查找陷阱)
6. [贪心算法陷阱](#六贪心算法陷阱)
7. [分治思想陷阱](#七分治思想陷阱)
8. [高精度运算陷阱](#八高精度运算陷阱)
9. [欧几里得算法陷阱](#九欧几里得算法陷阱)
10. [考场实战技巧](#十考场实战技巧)

---

## 一、链表操作陷阱

### 陷阱1：链表无法随机访问

```cpp
// ❌ 错误：链表不支持随机访问
int getNth(Node* head, int n) {
    return head[n];  // 编译错误！
}

// ✅ 正确：需要顺序遍历
int getNth(Node* head, int n) {
    Node* p = head;
    for (int i = 0; i < n && p; i++)
        p = p->next;
    return p->data;
}
```

**真题2503-1**：链表不具备的特点是？
- **答案**：A（可随机访问任意元素）

---

### 陷阱2：删除节点时忘记释放内存

```cpp
// ❌ 错误：内存泄漏
void deleteNode(Node*& head, int val) {
    Node* cur = head;
    while (cur->next) {
        if (cur->next->data == val) {
            cur->next = cur->next->next;  // 忘记delete！
        }
    }
}

// ✅ 正确：释放内存
void deleteNode(Node*& head, int val) {
    Node dummy(0);
    dummy.next = head;
    Node* cur = &dummy;
    while (cur->next) {
        if (cur->next->data == val) {
            Node* del = cur->next;
            cur->next = del->next;
            delete del;
        } else {
            cur = cur->next;
        }
    }
    head = dummy.next;
}
```

---

### 陷阱3：循环链表边界条件

```cpp
// ❌ 错误：死循环
void printCircular(CNode* head) {
    CNode* p = head;
    while (p != nullptr) {  // 循环链表永不为nullptr！
        cout << p->data << " ";
        p = p->next;
    }
}

// ✅ 正确：使用do-while
void printCircular(CNode* head) {
    if (!head) return;
    CNode* p = head;
    do {
        cout << p->data << " ";
        p = p->next;
    } while (p != head);
}
```

---

### 陷阱4：Floyd快慢指针边界

```cpp
bool hasCycle(Node* head) {
    if (!head || !head->next) return false;
    Node* slow = head;
    Node* fast = head->next;  // 注意：fast从head->next开始
    while (fast && fast->next) {
        if (slow == fast) return true;
        slow = slow->next;
        fast = fast->next->next;  // fast走两步
    }
    return false;
}
```

**真题2509-3**：Floyd快慢指针判断链表环，横线处应填？
- **答案**：A（slow = slow->next; fast = fast->next->next;）

---

## 二、递归与迭代陷阱

### 陷阱1：递归深度过大导致栈溢出

```cpp
// ❌ 危险：n较大时可能栈溢出
long long fibRec(int n) {
    if (n <= 1) return n;
    return fibRec(n-1) + fibRec(n-2);
}

// ✅ 安全：迭代实现
long long fibIter(int n) {
    if (n <= 1) return n;
    long long a = 0, b = 1;
    for (int i = 2; i <= n; i++) {
        long long c = a + b;
        a = b;
        b = c;
    }
    return b;
}
```

**真题2506-7**：递归调用层数过多引发错误的原因是？
- **答案**：A（栈空间溢出）

---

### 陷阱2：递归忘记终止条件

```cpp
// ❌ 错误：无限递归
int fun(int n) {
    return fun(n-2) - fun(n-1);  // 没有终止条件！
}

// ✅ 正确：有终止条件
int fun(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return fun(n-2) - fun(n-1);
}
```

---

### 陷阱3：记忆化递归缓存初始化

```cpp
// ❌ 错误：未初始化缓存
long long fibMemo(int n, vector<long long>& memo) {
    if (memo[n] != -1) return memo[n];  // memo未初始化！
    // ...
}

// ✅ 正确：初始化缓存
vector<long long> memo(n + 1, -1);
memo[0] = 0;
memo[1] = 1;
```

---

## 三、排序算法陷阱

### 陷阱1：快速排序最坏情况

```cpp
// ❌ 危险：已排序数组会导致O(N²)
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[low];  // 选首元素为基准
    // ...
}

// ✅ 优化：随机选择基准
int partition(vector<int>& arr, int low, int high) {
    int random = low + rand() % (high - low + 1);
    swap(arr[random], arr[high]);
    int pivot = arr[high];
    // ...
}
```

**真题2409-9**：快速排序对已排序数组（选首元素为基准）的行为是？
- **答案**：C（时间复杂度O(N²)）

---

### 陷阱2：归并排序空间复杂度

```cpp
// 归并排序需要O(N)额外空间
void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);  // 额外空间！
    // ...
}
```

---

### 陷阱3：快速排序不稳定

```cpp
// 快速排序不稳定示例：相等元素相对位置可能改变
// 输入：[(5,a), (3,b), (5,c)]
// 输出：[(3,b), (5,c), (5,a)]  // 两个5的顺序变了

// 归并排序稳定：相等元素保持相对位置
```

**真题2509-22**：快速排序和归并排序都是稳定的排序算法。
- **答案**：×（快速排序不稳定）

---

## 四、筛法陷阱

### 陷阱1：埃氏筛从i*i开始

```cpp
// ❌ 错误：从i开始会有重复标记
for (int i = 2; i <= n; i++) {
    if (is_prime[i]) {
        for (int j = i; j <= n; j += i)  // 从i开始！
            is_prime[j] = false;
    }
}

// ✅ 正确：从i*i开始
for (int i = 2; i * i <= n; i++) {
    if (is_prime[i]) {
        for (int j = i * i; j <= n; j += i)  // 从i*i开始
            is_prime[j] = false;
    }
}
```

**真题2406-6**：埃氏筛代码，横线处应填？
- **答案**：D（i*i）

---

### 陷阱2：线性筛break条件

```cpp
// ❌ 错误：忘记break
for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {
    is_prime[i * primes[j]] = false;
    // 忘记break！
}

// ✅ 正确：break防止重复筛选
for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {
    is_prime[i * primes[j]] = false;
    if (i % primes[j] == 0) break;  // 关键！
}
```

**真题2406-7**：线性筛代码，横线处应填？
- **答案**：A（i%p == 0）

---

### 陷阱3：埃氏筛 vs 线性筛速度误解

> **注意**：线性筛时间复杂度O(N)更低，但实际在小范围（n ≤ 10⁷）埃氏筛可能更快！

**真题2409-8**：关于埃氏筛和线性筛的比较，下列说法错误的是？
- **答案**：B（线性筛的速度往往优于埃氏筛）

---

## 五、二分查找陷阱

### 陷阱1：循环条件边界

```cpp
// ❌ 错误：可能死循环
while (left < right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] <= target)
        left = mid;  // 死循环！
    else
        right = mid - 1;
}

// ✅ 正确：left = mid + 1或right = mid
while (left < right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] <= target)
        left = mid + 1;
    else
        right = mid;
}
```

---

### 陷阱2：mid计算防溢出

```cpp
// ❌ 危险：可能溢出
int mid = (left + right) / 2;  // left+right可能溢出

// ✅ 安全：防溢出
int mid = left + (right - left) / 2;
```

---

### 陷阱3：链表无法二分查找

```cpp
// ❌ 错误：链表不支持随机访问，二分查找无意义
Node* binarySearch(Node* head, int target) {
    // 无法高效实现！
}
```

**真题2512-20**：二分查找仅适用于数组，不适用于链表。
- **答案**：√

---

## 六、贪心算法陷阱

### 陷阱1：贪心不一定最优

```cpp
// ❌ 错误：贪心不一定得到最优解
// 硬币面值[1, 3, 4]，找6
// 贪心：4+1+1=3枚
// 最优：3+3=2枚

int coinChange(vector<int>& coins, int amount) {
    sort(coins.rbegin(), coins.rend());  // 贪心
    // ...
}  // 不一定是最优解！
```

**真题2509-25**：贪心算法总能得到全局最优解。
- **答案**：×

---

### 陷阱2：判断贪心是否适用

```cpp
// 适用贪心的问题：
// - 活动选择
// - 霍夫曼编码
// - 最小生成树（Prim、Kruskal）
// - 最短路径（Dijkstra）

// 不适用贪心的问题：
// - 0-1背包
// - 旅行商问题
```

---

## 七、分治思想陷阱

### 陷阱1：汉诺塔时间复杂度

```cpp
// 汉诺塔递归次数：2^n - 1
// 时间复杂度：O(2^n)，不是O(NlogN)！

void hanoi(int n, char from, char to, char aux) {
    if (n == 1) {
        cout << from << " -> " << to << endl;
        return;
    }
    hanoi(n-1, from, aux, to);
    cout << from << " -> " << to << endl;
    hanoi(n-1, aux, to, from);
}
```

**真题2509-23**：分治算法求解汉诺塔，时间复杂度O(NlogN)。
- **答案**：×（O(2^N)）

---

### 陷阱2：分治必须有合并步骤

```cpp
// ❌ 错误：没有合并
int findMax(vector<int>& arr, int left, int right) {
    if (left == right) return arr[left];
    int mid = left + (right - left) / 2;
    int leftMax = findMax(arr, left, mid);
    int rightMax = findMax(arr, mid+1, right);
    return max(leftMax, rightMax);  // 有合并！
}
```

---

## 八、高精度运算陷阱

### 陷阱1：进位借位处理

```cpp
// ❌ 错误：进位处理错误
for (int i = 0; i < a.size() || i < b.size(); i++) {
    if (i < a.size()) carry += a[i];
    if (i < b.size()) carry += b[i];
    c.push_back(carry);  // 错误！
    carry /= 10;
}

// ✅ 正确：先取模再加进位
for (int i = 0; i < a.size() || i < b.size(); i++) {
    if (i < a.size()) carry += a[i];
    if (i < b.size()) carry += b[i];
    c.push_back(carry % 10);  // 先取模
    carry /= 10;
}
```

**真题2512-15**：高精度加法（数组低位在前），横线处应填？
- **答案**：B（c.push_back(carry%10); carry/=10;）

---

### 陷阱2：去除前导零

```cpp
// ❌ 错误：没有去除前导零
vector<int> sub(vector<int> a, vector<int> b) {
    // ...
    return c;  // 可能包含前导零
}

// ✅ 正确：去除前导零
while (c.size() > 1 && c.back() == 0) c.pop_back();
```

---

## 九、欧几里得算法陷阱

### 陷阱1：递归版空间复杂度

```cpp
// 递归版：需要O(logN)栈空间
int gcdRec(int a, int b) {
    if (b == 0) return a;
    return gcdRec(b, a % b);
}

// 迭代版：O(1)空间
int gcdIter(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

**真题2512-5**：关于欧几里得算法gcd1和gcd2的说法错误的是？
- **答案**：D（大数据时gcd1执行效率更高）

---

### 陷阱2：最小公倍数溢出

```cpp
// ❌ 危险：a*b可能溢出
int lcm(int a, int b) {
    return a * b / gcd(a, b);  // 可能溢出！
}

// ✅ 安全：先除后乘
int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}
```

---

## 十、考场实战技巧

### 10.1 时间分配

| 题型 | 分值 | 建议时间 |
|------|------|----------|
| 单选题 | 2分×30=60分 | 25分钟 |
| 判断题 | 2分×20=40分 | 15分钟 |
| **总计** | **100分** | **40分钟** |

### 10.2 答题顺序

1. **第一遍**：快速浏览，先做有把握的题
2. **第二遍**：回头攻克难题
3. **第三遍**：检查所有答案

### 10.3 常见坑点检查清单

- [ ] 链表遍历是否检查nullptr
- [ ] 递归是否有终止条件
- [ ] 排序算法是否考虑最坏情况
- [ ] 二分查找边界条件是否正确
- [ ] 贪心算法是否真的适用
- [ ] 高精度运算进位借位是否正确
- [ ] 欧几里得算法是否考虑大数据

### 10.4 高分策略

1. **链表题**：画图辅助理解
2. **递归题**：先写出终止条件
3. **排序题**：熟记时间复杂度
4. **二分题**：边界条件用具体例子验证
5. **贪心题**：先想反例验证是否适用
6. **高精度题**：用具体数字模拟执行
