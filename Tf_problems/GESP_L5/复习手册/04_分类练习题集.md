# C++五级分类练习题集

> 基于2023.9-2025.12共10套真题（250题）按考点分类
> **适用对象**：GESP C++五级考生
> **用途**：针对性练习、强化薄弱环节

---

## 目录

1. [链表操作（25题）](#一链表操作-25题)
2. [递归与迭代（25题）](#二递归与迭代-25题)
3. [排序算法（30题）](#三排序算法-30题)
4. [筛法求素数（20题）](#四筛法求素数-20题)
5. [二分查找（20题）](#五二分查找-20题)
6. [贪心算法（20题）](#六贪心算法-20题)
7. [分治思想（20题）](#七分治思想-20题)
8. [高精度运算（15题）](#八高精度运算-15题)
9. [欧几里得算法（15题）](#九欧几里得算法-15题)
10. [算法复杂度（20题）](#十算法复杂度-20题)
11. [参考答案](#十一参考答案)

---

## 一、链表操作（25题）

1. 以下哪种情况使用链表比数组更合适？
   - A. 数据量固定且读多写少
   - B. 需要频繁在中间或开头插入、删除元素
   - C. 需要高效随机访问元素
   - D. 存储空间必须连续

2. 链表不具备的特点是？
   - A. 可随机访问任意元素
   - B. 插入删除不移动元素
   - C. 无需预估存储空间
   - D. 存储空间与元素个数成正比

3. 双链表查找歌曲的时间复杂度是？
   - A. O(1)
   - B. O(N)
   - C. O(logN)
   - D. O(NlogN)

4. 双向链表删除节点p（前后均非空），错误的操作是？
   - A. p->next->prev = p->next; p->prev->next = p->prev; delete p;
   - B. p->prev->next = p->next; p->next->prev = p->prev; delete p;
   - C. p->next->prev = p->prev; p->next->prev->next = p->next; delete p;
   - D. p->prev->next = p->next; p->prev->next->prev = p->prev; delete p;

5. 单链表和双链表删除指定节点的时间复杂度说法正确的是？
   - A. 双链表O(1)，单链表O(1)
   - B. 双链表O(N)，单链表O(1)
   - C. 双链表O(1)，单链表O(N)
   - D. 双链表O(N)，单链表O(N)

6. 单链表删除非尾节点p（未知头节点），可拷贝p->next数据并删除p->next。( )

7. 链表存储要求内存地址连续。( )

8. 数组和链表都是线性表，链表的优点是插入删除不移动元素，且能随机查找。( )

9. 单链表只支持在表头插入和删除。( )

10. 双向链表首尾相接构成循环链表。( )

11. 链表的优点是插入删除不移动元素，且能随机查找。( )

12. Floyd快慢指针判断链表环，横线处应填？
    ```cpp
    bool hasCycle(Node* head) {
        if (!head || !head->next) return false;
        Node* slow = head;
        Node* fast = head->next;
        while (fast && fast->next) {
            if (slow == fast) return true;
            ___; // 横线处
        }
        return false;
    }
    ```
    - A. slow = slow->next; fast = fast->next->next;
    - B. slow = fast->next; fast = slow->next->next;
    - C. slow = slow->next; fast = slow->next->next;
    - D. slow = fast->next; fast = fast->next->next;

13. 函数removeElements删除单链表中所有结点值等于val的结点，横线处应填？
    ```cpp
    Node* removeElements(Node* head, int val) {
        Node dummy(0);
        dummy.next = head;
        Node* cur = &dummy;
        while (cur->next) {
            if (cur->next->val == val) {
                ___; // 横线处
            } else {
                cur = cur->next;
            }
        }
        return dummy.next;
    }
    ```
    - A. Node* del = cur; cur = del->next; delete del;
    - B. Node* del = cur->next; cur->next = del; delete del;
    - C. Node* del = cur->next; cur->next = del->next; delete del;
    - D. Node* del = cur->next; delete del; cur->next = del->next;

14. 双向链表is_empty()不能填写的是？
    ```cpp
    struct DoubleLink {
        Node* head;
        Node* tail;
        int size;
        bool is_empty() const {
            ___;
        }
    }
    ```
    - A. return head == nullptr;
    - B. return tail == nullptr;
    - C. return head.data == 0;
    - D. return size == 0;

15. 双向链表尾部添加节点，横线处应填？
    ```cpp
    void append(int data) {
        Node* newNode = new Node{data, nullptr, nullptr};
        if (is_empty()) {
            head = tail = newNode;
        } else {
            ___;
        }
        ++size;
    }
    ```
    - A. tail->next = newNode;
    - B. newNode->prev = tail; tail = newNode;
    - C. tail = newNode; newNode->prev = tail; tail->next = newNode;
    - D. tail->next = newNode; newNode->prev = tail; tail = newNode;

16. 循环单链表最后一个节点的next指针指向？
    - A. 当前节点
    - B. nullptr
    - C. 第一个节点
    - D. 上一个节点

17. 循环单链表遍历输出，横线处应填？
    ```cpp
    void printList(Node* head) {
        if (head == nullptr) return;
        Node* p = head;
        ___; // 横线处
        cout << endl;
    }
    ```
    - A. while(p!=nullptr){ cout<<p->data<<" "; p=p->next; }
    - B. while(p->next!=nullptr){ cout<<p->data<<" "; p=p->next; }
    - C. do{ cout<<p->data<<" "; p=p->next; }while(p!=head);
    - D. for(;p;p=p->next){ cout<<p->data<<" "; }

18. 区块链插入新区块，横线处应填？
    ```cpp
    void addBlock(const string& data) {
        ___; // 横线处
    }
    ```
    - A. Block* newBlock = new Block(tail->index+1, data, tail); tail = newBlock->prev;
    - B. Block* newBlock = new Block(tail->index+1, data, tail); tail = newBlock;
    - C. Block* newBlock = new Block(tail->index+1, data, tail->prev); tail = newBlock;
    - D. Block* newBlock = new Block(tail->index+1, data, tail->prev); tail = newBlock->prev;

19. 链表通过指针实现高效增删，但访问效率低、占用内存多，对缓存不友好。( )

20. 双链表头部插入歌曲，横线处应填？
    ```cpp
    void insert(dl_node *head, string my_song) {
        dl_node* p = new dl_node;
        p->song = my_song;
        p->prev = nullptr;
        p->next = head;
        if (head != nullptr) {
            ___; // 横线处
        }
        head = p;
    }
    ```
    - A. head->next->prev = p;
    - B. head->next = p;
    - C. head->prev = p;
    - D. 触发异常

21. 虚拟头节点删除链表元素，横线处应填？
    ```cpp
    void removeElements(LinkedNode* head, int val) {
        LinkedNode* dummyHead = new LinkedNode(0);
        ___; // 横线处
    }
    ```
    - A. dummyHead->next = head; cur = dummyHead;
    - B. dummyHead->next = head->next; cur = dummyHead;
    - C. dummyHead->next = head; cur = dummyHead->next;
    - D. dummyHead->next = head->next; cur = dummyHead->next;

22. 循环链表解决约瑟夫问题，横线处应填？
    ```cpp
    int findLastSurvival(int n, int k) {
        while (p->next != p) {
            for (int count=1; count<k; count++) {
                prev = p;
                p = p->next;
            }
            ___; // 横线处
        }
    }
    ```
    - A. prev->next = p->next; delete p; p = prev->next;
    - B. prev->next = p->next; delete p; p = prev->next;
    - C. p = prev->next; delete p; prev->next = p->next;
    - D. prev->next = p->next; p = prev->next; delete p;

23. 双向循环链表初始化空链表，横线处应填？
    ```cpp
    void InitLinkedList(LinkedList* list) {
        list->head = new ListNode<T>;
        list->tail = new ListNode<T>;
        ___; // 横线处
    }
    ```
    - A. list->head->prev = list->head; list->tail->prev = list->head;
    - B. list->head->next = list->tail; list->tail->prev = list->head;
    - C. list->head->next = list->tail; list->tail->next = list->head;
    - D. list->head->next = list->tail; list->tail->next = nullptr;

24. 函数isPerfectNumber判断完全数，横线处应填？
    ```cpp
    bool isPerfectNumber(int n) {
        if(n <= 1) return false;
        int sum = 1;
        for(int i = 2; ______; i++) {
            if(n % i == 0) {
                sum += i;
                if(i != n/i) sum += n/i;
            }
        }
        return sum == n;
    }
    ```
    - A. i <= n
    - B. i*i <= n
    - C. i <= n/2
    - D. i < n

25. 单链表中已知非尾节点p，可通过拷贝p->next数据并删除p->next实现删除p。( )

---

## 二、递归与迭代（25题）

26. 以下斐波那契数列代码中，函数fibo()属于哪种算法？
    - A. 枚举算法
    - B. 贪心算法
    - C. 迭代算法
    - D. 递归算法

27. 递归版gcd()的说法错误的是？
    - A. 递归实现
    - B. 代码量少，易理解
    - C. 大数据时需较多辅助空间
    - D. 大数据时执行效率更高

28. 递归斐波那契的时间复杂度是？
    - A. O(N)
    - B. O(logN)
    - C. O(2^N)
    - D. O(N²)

29. 递归调用层数过多引发错误的原因是？
    - A. 栈空间溢出
    - B. 堆空间溢出
    - C. 队列空间溢出
    - D. 链表空间溢出

30. 关于factorialA和factorialB的说法错误的是？
    - A. 功能相同
    - B. 时间复杂度均O(N)
    - C. factorialA是递归方式
    - D. factorialB是递归方式

31. 关于sumA和sumB的说法错误的是？
    ```cpp
    int sumA(int n) { int res = 0; for (int i=1; i<=n; i++) res += i; return res; }
    int sumB(int n) { if (n == 1) return 1; return n + sumB(n-1); }
    ```
    - A. sumA是迭代思想
    - B. sumB是递归方式
    - C. sumB时间效率更高
    - D. 功能相同

32. 关于fibA和fibB的说法错误的是？
    - A. 功能相同
    - B. fibA是递推方式
    - C. fibB是递归方式
    - D. fibA时间复杂度O(N)，fibB O(N²)

33. 递归实现的斐波那契数列时间复杂度为O(2^n)。( )

34. 递归函数必须有终止条件，否则可能栈溢出。( )

35. 所有递归算法都可以转换为迭代算法。( )

36. 递归比迭代更耗费内存空间。( )

37. gcd(24,36)的调用顺序是？
    ```cpp
    int gcd(int a, int b) {
        int big = a>b ? a:b;
        int small = a<b ? a:b;
        if (big%small ==0) return small;
        return gcd(small, big%small);
    }
    ```
    - A. gcd(24,36)→gcd(24,12)→gcd(12,0)
    - B. gcd(24,36)→gcd(12,24)→gcd(0,12)
    - C. gcd(24,36)→gcd(24,12)
    - D. gcd(24,36)→gcd(12,24)

38. fun(7)的返回值是？
    ```cpp
    int fun(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        return fun(n-2) - fun(n-1);
    }
    ```
    - A. 0
    - B. 1
    - C. 21
    - D. -11

39. fun(4)的输出序列是？
    ```cpp
    int fun(int n) {
        cout << n << " ";
        if (n == 1) return 1;
        if (n == 2) return 2;
        return fun(n-2) - fun(n-1);
    }
    ```
    - A. 4 3 2 1
    - B. 1 2 3 4
    - C. 4 2 3 1 2
    - D. 4 2 3 2 1

40. 递归版斐波那契数列时间复杂度为O(2^n)。( )

41. 阶乘计算的两种方式，说法正确的是？
    - A. 时间复杂度均为O(N)
    - B. 空间复杂度均为O(N)
    - C. 空间复杂度均为O(1)
    - D. factorial1时间复杂度O(2^n)，factorial2为O(N)

42. 关于gcd0和gcd1的说法错误的是？
    - A. gcd0时间复杂度O(logN)
    - B. gcd1时间复杂度O(N)
    - C. gcd0效率更高
    - D. gcd1的循环应改为i>1

43. 调用puzzle(7)会无限递归。( )
    ```cpp
    int puzzle(int n) {
        if (n==1) return 1;
        if (n%2==0) return puzzle(n/2);
        else return puzzle(3*n+1);
    }
    ```

44. fun(20,12)的返回值是？
    ```cpp
    int fun(int a, int b) {
        if (a % b == 0) return b;
        else return fun(b, a % b);
    }
    ```
    - A. 20
    - B. 12
    - C. 4
    - D. 2

45. fun(7)的返回值是？
    ```cpp
    int fun(int n) {
        if (n == 1) return 1;
        else if (n >=5) return n * fun(n-2);
        else return n * fun(n-1);
    }
    ```
    - A. 105
    - B. 840
    - C. 210
    - D. 420

46. 递归函数必须有终止条件。( )

47. fib函数计算斐波那契数，时间复杂度O(2^n)。( )
    ```cpp
    int fib(int n) {
        if(n<=1) return n;
        return fib(n-1)+fib(n-2);
    }
    ```

48. 递归版gcd()的说法错误的是？
    - A. 递归实现
    - B. 代码量少，易理解
    - C. 大数据时需较多辅助空间
    - D. 大数据时执行效率更高

49. gcd(84,60)的第二步计算的数是？
    - A. 84和60
    - B. 60和24
    - C. 24和12
    - D. 12和0

50. 求最大公约数，横线处应填？
    ```cpp
    int gcd0(int a, int b) {
        if (a < b) swap(a, b);
        while(b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }
        return ______;
    }
    ```
    - A. b
    - B. a
    - C. temp
    - D. a * b

---

## 三、排序算法（30题）

51. 归并排序merge函数的递归调用次数约为？
    - A. N
    - B. NlogN
    - C. 2N
    - D. logN

52. 快速排序对已排序数组（选首元素为基准）的行为是？
    - A. 表现最好
    - B. 时间复杂度O(NlogN)
    - C. 时间复杂度O(N²)
    - D. 无法排序

53. 快速排序最坏情况的时间复杂度是？
    - A. O(N)
    - B. O(NlogN)
    - C. O(N²)
    - D. O(logN)

54. 归并排序的时间复杂度是O(NlogN)。( )

55. 冒泡排序算法优于归并排序。( )

56. 归并排序merge函数仅被调用一次。( )

57. 归并排序的最好、最坏、平均时间复杂度均O(NlogN)。( )

58. 快速排序和归并排序都是稳定排序。( )

59. 快速排序时间复杂度总比插入排序低。( )

60. 插入排序有时比快速排序时间复杂度更低。( )

61. 插入排序的时间复杂度是O(NlogN)。( )

62. 快速排序是稳定排序。( )

63. 归并排序通常是稳定的。( )

64. 插入排序是不稳定排序。( )

65. 冒泡排序不是原地排序。( )

66. 不稳定的排序是？
    - A. 选择排序
    - B. 插入排序
    - C. 归并排序
    - D. 冒泡排序

67. 快速排序partition函数，横线处应填？
    ```cpp
    int partition(vector<int>& arr, int low, int high) {
        int pivot = arr[high];
        int i = low -1;
        for (int j=low; j<high; j++) {
            ___; // 横线处
        }
        swap(arr[i+1], arr[high]);
        return i+1;
    }
    ```
    - A. if (arr[j]>pivot) { i++; swap(arr[i], arr[j]); }
    - B. if (arr[j]<pivot) { i++; swap(arr[i], arr[j]); }
    - C. if (arr[j]<pivot) { swap(arr[i], arr[j]); i++; }
    - D. if (arr[j]==pivot) { i++; swap(arr[i], arr[j]); }

68. 归并排序merge函数，横线处应填？
    ```cpp
    while (i <= mid) { tmp[k++] = nums[i++]; }
    while (________) { // 横线处
        tmp[k++] = nums[j++];
    }
    ```
    - A. i < mid
    - B. j < right
    - C. i <= mid
    - D. j <= right

69. 关于归并排序的说法不正确的是？
    - A. 平均时间复杂度O(NlogN)
    - B. 需要O(N)额外空间
    - C. 最坏时间复杂度O(N²)
    - D. 适合大规模数据

70. 关于快速排序的说法错误的是？
    - A. i记录大于基准值的边界
    - B. 随机基准避免最坏情况
    - C. 平均时间复杂度O(NlogN)
    - D. 稳定排序

71. 关于快速排序代码的说法错误的是？
    - A. 快速排序平均情况下运行速度快，常数小、就地排序，实践中常比归并排序高效
    - B. 平均时间复杂度O(NlogN)
    - C. 最差时间复杂度O(N²)
    - D. 划分函数中"从右往左查找"与"从左往右查找"顺序可交换

72. 快速排序和归并排序平均时间复杂度均O(NlogN)，且都是稳定排序。( )

73. 快速排序选择"首、中、尾"中间值作为基准，可降低最坏情况概率。( )

74. 排序数组使偶数在前奇数在后，横线处应填？
    ```cpp
    void sortA(int lstA[],int n){
        for(int i=n-1;i>0;i--)
            for(int j=0;j<i;j++)
                if(___) // 横线处
                    swap(lstA[j], lstA[j+1]);
    }
    ```
    - A. !isEven(lstA[j]) && isEven(lstA[j+1])
    - B. isEven(lstA[j]) && !isEven(lstA[j+1])
    - C. lstA[j] > lstA[j+1]
    - D. lstA[j] < lstA[j+1]

75. C++的qsort库函数是不稳定排序。( )

76. 关于排序的说法正确的是？
    - A. 快速排序是稳定排序
    - B. 归并排序通常是稳定的
    - C. 插入排序是不稳定排序
    - D. 冒泡排序不是原地排序

77. 排序向量并筛选奇数，两个横线处应填？
    ```cpp
    sort(lstA.begin(), lstA.end(), ___); // 代码1
    if(___) // 代码2
        lstB.push_back(lstA[i]);
    ```
    - A. compare 和 isOdd(lstA[i])
    - B. compare(x1,y1) 和 isOdd
    - C. compare 和 isOdd
    - D. compare(x1,y1) 和 isOdd(lstA[i])

78. 对数组int arr[]={2,6,3,5,4,8,1,0,9,10}执行sort后结果为{0,1,2,3,4,5,6,8,9,10}。( )

79. 哪种排序算法不能保证下一趟选出最大/最小数据？
    - A. 选择排序
    - B. 快速排序
    - C. 堆排序
    - D. 冒泡排序

80. 快速排序partition函数，横线处应填？
    ```cpp
    int partition(vector<int>& arr, int low, int high) {
        int i = low, j = high;
        int pivot = arr[low];
        while (i < j) {
            while (i < j && arr[j] >= pivot) j--;
            while (i < j && arr[i] <= pivot) i++;
            if (i < j) swap(arr[i], arr[j]);
        }
        swap(arr[i], arr[low]);
        return i;
    }
    ```

---

## 四、筛法求素数（20题）

81. 找N以内质数的埃氏筛法比线性筛法效率更高。( )

82. 唯一分解定理表明大于1的整数可唯一分解为质数乘积。( )

83. 唯一分解定理的描述是？
    - A. 任意整数可分解为素数乘积
    - B. 每个合数可唯一分解为素数乘积
    - C. 不同整数可分解为相同素数乘积
    - D. 以上都不对

84. 唯一分解正确的是？
    - A. 18=3×6
    - B. 28=4×7
    - C. 36=2×3×6
    - D. 30=2×3×5

85. 唯一分解定理描述的是？
    - A. 每个整数都能表示为任意素数的乘积
    - B. 每个大于1的整数能唯一分解为素数幂乘积（忽略顺序）
    - C. 合数不能分解为素数乘积
    - D. 素数只有两个因子：1和自身

86. 线性筛每个合数仅被最小质因子筛一次，效率更高。( )

87. 线性筛效率高于埃氏筛。( )

88. 求解不大于n的素数，线性筛应优先于埃氏筛，因线性筛时间复杂度O(N)更低。( )

89. 埃氏筛和线性筛的时间复杂度都是O(NloglogN)。( )

90. 线性筛时间复杂度O(N)。( )

91. 素数的线性筛法时间复杂度为？
    - A. O(N)
    - B. O(NlogN)
    - C. O(NloglogN)
    - D. O(√N)

92. 关于埃氏筛和线性筛的比较，下列说法错误的是？
    - A. 埃氏筛可能会对同一个合数进行多次标记
    - B. 线性筛的理论时间复杂度更优，所以线性筛的速度往往优于埃氏筛
    - C. 线性筛保证每个合数只被其最小质因子筛到一次
    - D. 对于常见范围（n ≤ 10⁷），埃氏筛因实现简单，常数较小，其速度往往优于线性筛

93. 埃氏筛代码，横线处应填？
    ```cpp
    for(int i = 2; i <= n; i++) {
        if(is_prime[i]) {
            for(int j = ______; j <= n; j += i)
                is_prime[j] = false;
        }
    }
    ```
    - A. i
    - B. i+1
    - C. i*2
    - D. i*i

94. 线性筛代码，横线处应填？
    ```cpp
    for (int i=2;i <= n; i++) {
        if (is_prime[i]) primes.push_back(i);
        for (int p:primes){
            if(p * i >n) break;
            is_prime[p*i] = false;
            if(____) break;
        }
    }
    ```
    - A. i%p == 0
    - B. p%i == 0
    - C. i==p
    - D. i*p ==n

95. 线性筛代码，横线处应填？
    ```cpp
    for (int i=2; i<=n/2; i++) {
        if (is_prime[i]) primes.push_back(i);
        for (int j=0, ___; j++) {
            is_prime[i*primes[j]] = false;
            if (i%primes[j] ==0) break;
        }
    }
    ```
    - A. j<primes.size()
    - B. i*primes[j] <=n
    - C. j<primes.size()&&i*primes[j]<=n
    - D. j<=n

96. 埃氏筛代码的正确说法是？
    - A. 时间复杂度O(N√N)
    - B. 从i*i开始标记，减少重复
    - C. 输出所有小于等于n的奇数
    - D. sieve_Eratosthenes(10)返回[2,3,5,7,9]

97. 线性筛代码的正确说法是？
    - A. 时间复杂度O(N)
    - B. 每个合数被所有质因子标记
    - C. 与埃氏筛思路完全相同
    - D. 以上都不对

98. 唯一分解定理描述的内容是？
    - A. 任何正整数可表示为两个素数之和
    - B. 任何大于1的合数可唯一分解为有限个质数的乘积
    - C. 最大公约数=最小公倍数/两数乘积
    - D. 所有素数都是奇数

99. 唯一分解定理求质因子，横线处应填？
    ```cpp
    vector<int> get_prime_factors(int n) {
        vector<int> factors;
        if (n<=1) { cout<<"输入需大于1"<<endl; return factors; }
        while (n%2 ==0) { factors.push_back(2); n/=2; }
        ___; // 横线处
        while (n%i ==0) { factors.push_back(i); n/=i; }
        if (n>2) factors.push_back(n);
        return factors;
    }
    ```
    - A. for (int i=3;i<=n;i++)
    - B. for (int i=3;i*i<=n;i++)
    - C. for (int i=3;i<=n;i+=2)
    - D. for (int i=3;i*i<=n;i+=2)

100. get_prime_factors的时间复杂度是？
    - A. O(N²)
    - B. O(√N)
    - C. O(N)
    - D. O(logN)

---

## 五、二分查找（20题）

101. 二分查找序列[1,3,6,9,17,31,39,52,61,79,81,90,96]中的82，循环次数是？
    - A. 2
    - B. 5
    - C. 3
    - D. 4

102. 二分查找82，比较的元素是？
    - A. 52,61,81,90
    - B. 52,79,90,81
    - C. 39,79,90,81
    - D. 39,79,90

103. 二分查找31，while循环执行次数？
    - A. 1
    - B. 2
    - C. 3
    - D. 4

104. 二分法在[1,100]内猜数，最多需要猜多少次？
    - A. 100
    - B. 10
    - C. 7
    - D. 5

105. C++中可以用二分法查找链表中的元素。( )

106. 二分查找要求序列有序，否则无法保证正确性。( )

107. 二分查找仅适用于数组，不适用于链表。( )

108. 二分查找适用于有序和无序数组。( )

109. 查字典按"中间页排除一半"属于二分查找。( )

110. 上述binarySearch算法的时间复杂度是？
    - A. O(N)
    - B. O(logN)
    - C. O(NlogN)
    - D. O(N²)

111. 二分查找的时间复杂度是O(logN)。( )

112. 关于二分查找函数的描述不正确的是？
    - A. 每次排除一半搜索区间
    - B. 递归求解，规模减半
    - C. 无target时递归不终止
    - D. 时间复杂度O(logN)

113. 二分查找mid计算，最佳代码是？
    ```cpp
    while (left <= right) {
        ___;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid+1;
        else right = mid-1;
    }
    ```
    - A. int mid = left + (right-left)/2;
    - B. int mid = left;
    - C. int mid = (left+right)/2;
    - D. int mid = right;

114. 查找第一个大于等于x的元素位置，代码逻辑正确的是？
    - A. 逻辑正确
    - B. 循环条件应改为l<=r
    - C. mid计算错误
    - D. 边界条件不对

115. 二分查找最后一个target的正确说法是？
    - A. 重复target时返回最后一个
    - B. target小于所有元素返回0
    - C. 循环条件改为low<=high更准确
    - D. mid计算改为(low+high)/2效果相同

116. 查找target左边界，横线处应填？
    ```cpp
    int getLeftBoundary(vector<int>& nums, int target) {
        int left=0, right=nums.size()-1;
        while (left < right) {
            int middle = left + (right-left)/2;
            if (target <= nums[middle])
                ___;
            else
                left = middle+1;
        }
        return nums[left]==target ? left : -1;
    }
    ```
    - A. right = middle-1
    - B. right = middle
    - C. right = middle+1
    - D. 以上都不对

117. 二分法找切割木头的最小x，横线处应填？
    ```cpp
    bool check(int L,int K,int x) {
        int cuts=(L-1)/x;
        return cuts <= K;
    }
    int binary_cut(int L, int K) {
        int l=1, r=L;
        while(l<r) {
            int mid=l+(r-l)/2;
            ___;
        }
        return l;
    }
    ```
    - A. if(check(L,K,mid)) r=mid; else l=mid+1;
    - B. if(check(L,K,mid)) r=mid+1; else l=mid+1;
    - C. if(check(L,K,mid)) r=mid+1; else l=mid-1;
    - D. if(check(L,K,mid)) r=mid+1; else l=mid;

118. 二分查找19（数组{5,13,19,21,37,56,64,75,88,92,100}）的比较次数是2。( )

119. n×n有序矩阵找第k小元素，两处横线应填？
    ```cpp
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (countLE(matrix, mid) >= k) { ______ }
            else { ______ }
        }
        return lo;
    }
    ```
    - A. hi = mid-1；lo = mid+1
    - B. hi = mid；lo = mid
    - C. hi = mid；lo = mid+1
    - D. hi = mid+1；lo = mid

120. 二分查找仅适用于有序数据，无序数据单次查找时排序再二分不划算。( )

---

## 六、贪心算法（20题）

121. 以下最少币种组合代码的实现算法是？
    - A. 枚举算法
    - B. 贪心算法
    - C. 迭代算法
    - D. 递归算法

122. 贪心算法的核心思想是？
    - A. 每一步做当前最优选择
    - B. 每一步选局部最优解
    - C. 每一步选全局最优解
    - D. 以上都对

123. 贪心算法的解可能不是最优解。( )

124. 贪心算法的局部最优解必为全局最优解。( )

125. 贪心算法可以达到局部最优，但可能不是全局最优解。( )

126. 贪心算法总能得到全局最优解。( )

127. 贪心算法是通用解决方案。( )

128. 贪心算法不回溯，分治算法分解子问题再合并。( )

129. 贪心算法的核心特征是？
    - A. 总是选择当前最优解
    - B. 回溯尝试所有可能
    - C. 分阶段解决子问题
    - D. 总能找到最优解

130. 贪心算法安排任务求最大利润，横线处应填？
    ```cpp
    for(int t=task.deadline;t>=1;t--) {
        if(!slot[t]) {
            ___;
            break;
        }
    }
    ```
    - A. slot[t] = true; totalProfit += task.profit;
    - B. slot[t] = false; totalProfit += task.profit;
    - C. slot[t] = true; totalProfit = task.profit;
    - D. slot[t] = false; totalProfit = task.profit;

131. 电影院最多安排不重叠电影，横线处应填？
    ```cpp
    sort(movies.begin(), movies.end(), [](const vector<int>& a, const vector<int>& b) { ______ });
    for (int i = 1; i < movies.size(); i++) {
        if (movies[i][0] >= lastEnd) {
            count++;
            ______ = movies[i][1];
        }
    }
    ```
    - A. a[0] < b[0] 和 lastEnd
    - B. a[1] < b[1] 和 lastEnd
    - C. a[0] < b[0] 和 movies[i][0]
    - D. a[1] < b[1] 和 movies[i][0]

132. 硬币找零代码的正确说法是？
    - A. 贪心算法
    - B. 总能找到最优解
    - C. 枚举算法
    - D. 分治算法

133. 100元买最多商品，选最便宜的，体现分治思想。( )

134. 过河船数代码采用的思想是？
    - A. 枚举算法
    - B. 贪心算法
    - C. 迭代算法
    - D. 递归算法

135. Dijkstra算法是贪心算法。( )

136. 贪心算法的局部最优解不一定是全局最优解。( )

137. 贪心算法的当前最优解必为全局最优解。( )

138. 贪心算法的局部最优解必为全局最优解。( )

139. 贪心算法总能得到全局最优解。( )

140. 插入排序时间复杂度总是比快速排序低。( )

---

## 七、分治思想（20题）

141. 归并排序的mergeSort调用涉及的算法是？
    - A. 搜索算法
    - B. 分治算法
    - C. 贪心算法
    - D. 递推算法

142. 归并排序的基本思想是？
    - A. 将数组分成两个子数组，分别排序后合并
    - B. 随机选枢轴划分数组
    - C. 从末尾开始与前一个元素比较交换
    - D. 比较相邻元素，顺序错误则交换

143. 归并排序是分治算法应用，时间复杂度O(NlogN)。( )

144. 分治算法将大问题分解为子问题，解决后合并结果。( )

145. 全国人口普查按省市县乡分解，是分治策略。( )

146. 分治策略可提升算法效率，且利于并行优化。( )

147. 分治算法效率通常比直接求解低。( )

148. 归并排序体现分治思想。( )

149. 分治算法的正确说法是？
    - A. 将大问题分解为子问题，解决后合并
    - B. 归并排序不是分治应用
    - C. 用于小规模问题
    - D. 时间复杂度优于O(NlogN)

150. 关于分治算法的不正确说法是？
    - A. 分解子问题、解决后合并
    - B. 归并排序采用分治
    - C. 快速排序采用分治
    - D. 冒泡排序采用分治

151. 分治求最大子数组和，说法错误的是？
    - A. 采用分治算法
    - B. 采用贪心算法
    - C. 时间复杂度O(NlogN)
    - D. 采用递归方式

152. 求最大值算法的错误说法是？
    - A. 分治算法
    - B. 递归实现
    - C. 贪心算法
    - D. 非递推算法

153. 分治算法求解汉诺塔，时间复杂度O(NlogN)。( )

154. 迭代求最大值的错误说法是？
    - A. 迭代算法
    - B. 时间复杂度O(N)
    - C. 无栈开销
    - D. 与递归版空间复杂度相同

155. 递归实现归并排序，横线处应填？
    ```cpp
    void mergeSort(int SList[],int TList[],int s,int t,int len){
        if(s==t){ TList[s] = SList[s]; return; }
        int* T2=new int[len];
        int m=(s+t)/2;
        ___; // 横线处：两次mergeSort调用
        merge(T2, SList, s, m, t);
        delete T2;
        return;
    }
    ```
    - A. mergeSort(SList, T2, s, m, len)，mergeSort(SList, T2, m, t, len)
    - B. mergeSort(SList, T2, s, m-1, len)，mergeSort(SList, T2, m+1, t, len)
    - C. mergeSort(SList, T2, s, m, len)，mergeSort(SList, T2, m+1, t, len)
    - D. mergeSort(SList, T2, s, m-1, len)，mergeSort(SList, T2, m-1, t, len)

156. 快速排序中，主元素影响？
    - A. 不影响
    - B. 时间复杂度
    - C. 空间复杂度
    - D. 时间和空间复杂度

157. 递归函数避免无限递归的条件是？
    - A. 有终止条件
    - B. 参数递减/递增
    - C. 返回值固定
    - D. 以上都对

158. 分治思想求数组最大值，正确代码是？
    - A. if (low==high) return arr[low]; int mid=(low+high)/2; return arr[mid];
    - B. if (low>=high) return arr[low]; int mid=(low+high)/2; int leftMax=findMax(arr,low,mid-1); int rightMax=findMax(arr,mid,high); return leftMax+rightMax;
    - C. if (low>high) return 0; int mid=(low+high)/2; int leftMax=findMax(arr,low,mid); int rightMax=findMax(arr,mid+1,high); return leftMax*rightMax;
    - D. if (low==high) return arr[low]; int mid=(low+high)/2; int leftMax=findMax(arr,low,mid); int rightMax=findMax(arr,mid+1,high); return leftMax>rightMax ? leftMax : rightMax;

159. 分治算法将大问题分解为子问题，解决后合并结果。( )

160. 归并排序mergeSort调用涉及的算法是？
    - A. 搜索算法
    - B. 分治算法
    - C. 贪心算法
    - D. 递推算法

---

## 八、高精度运算（15题）

161. 以下代码能将十进制N转换为八进制并输出。( )

162. 关于高精度运算的说法错误的是？
    - A. 处理大整数或多位小数运算
    - B. 大整数除小整数可逐位尝试
    - C. 高精度乘法时间仅与较长数位数有关
    - D. 加法关键是逐位相加和进位

163. 数组模拟大整数加法，横线处应填？
    ```cpp
    for(int i=0;i<a.size() || i<b.size();i++){
        if(i<a.size()) t += a[i];
        if(i<b.size()) t += b[i];
        ___;
    }
    ```
    - A. c.push_back(t%10)，t=t%10
    - B. c.push_back(t/10)，t=t%10
    - C. c.push_back(t/10)，t=t/10
    - D. c.push_back(t%10)，t=t/10

164. 高精度减法借位，横线处应填？
    ```cpp
    for (int i = 0; i < len2; i++) {
        if (a[i] < b[i]) {
            ___;
            a[i] += 10;
        }
        int t = a[i] - b[i];
        c.push_back(t);
    }
    ```
    - A. a[i+1]--;
    - B. a[i]--;
    - C. b[i+1]--;
    - D. b[i]--;

165. 高精度乘法处理进位，横线处应填？
    ```cpp
    for (int k=0; k<c.size(); k++) {
        ___;
        c[k] = temp%10;
        carry = temp/10;
    }
    ```
    - A. int temp = c[k];
    - B. int temp = c[k] + carry;
    - C. int temp = c[k] - carry;
    - D. int temp = c[k] * carry;

166. 高精度加法（数组低位在前），横线处应填？
    ```cpp
    for(int i=0;i<a.size()||i<b.size();i++) {
        if(i<a.size()) carry +=a[i];
        if(i<b.size()) carry +=b[i];
        ___;
    }
    ```
    - A. c.push_back(carry/10); carry%=10;
    - B. c.push_back(carry%10); carry/=10;
    - C. c.push_back(carry%10);
    - D. c.push_back(carry); carry/=10;

167. 关于高精度减法函数的正确说法是？
    - A. a<b时返回负数
    - B. 输入数字正序存储（如500存储为{5,0,0}）
    - C. 时间复杂度O(a.size()+b.size())
    - D. 结果为0时仍有多个元素

168. 高精度除法横线处应填？
    ```cpp
    for (int i=a.len - b.len; i>=0; i--) {
        if (r.len>1 || r.d[0]!=0) {
            for (int j=r.len; j>0; j--)
                r.d[j] = r.d[j-1];
            ___;
        }
    }
    ```
    - A. r.d[0] = a.d[i]; r.len++;
    - B. r.d[i] = a.d[i]; r.len++;
    - C. r.d[i] = a.d[i]; r.len=1;
    - D. r.d[0] = a.d[i]; r.len=1;

169. 数组表示的整数+1，横线处应填？
    ```cpp
    for (int i = digits.size() - 1; i >= 0; --i) {
        if (digits[i] < 9) {
            digits[i] += 1;
            return digits;
        }
        ___;
    }
    digits.insert(digits.begin(), 1);
    return digits;
    ```
    - A. digits[i] = 0;
    - B. digits[i] = 9;
    - C. digits[i] = 1;
    - D. digits[i] = 10;

170. 两个长度为n的有序数组合并，最坏情况最少比较次数？
    - A. n
    - B. 2n-1
    - C. n-1
    - D. 2n

171. 高精度加法，横线处应填？
    - A. result = to_string(sum%10) + result;
    - B. result = to_string(carry%10) + result;
    - C. result = to_string(sum/10) + result;
    - D. result = to_string(sum%10+carry) + result;

172. 关于高精度运算的说法错误的是？
    - A. 处理大整数或多位小数运算
    - B. 大整数除小整数可逐位尝试
    - C. 高精度乘法时间仅与较长数位数有关
    - D. 加法关键是逐位相加和进位

173. 代码能输出质因数列表（如8:[2,2,2]）。( )

174. 关于高精度减法函数的正确说法是？
    - A. a<b时返回负数
    - B. 输入数字正序存储（如500存储为{5,0,0}）
    - C. 时间复杂度O(a.size()+b.size())
    - D. 结果为0时仍有多个元素

175. lcm(a,b)=a*b/gcd(a,b)能正确求最小公倍数。( )

---

## 九、欧几里得算法（15题）

176. 欧几里得算法函数计算的是？
    - A. 最小公倍数
    - B. 最大公共质因子
    - C. 最大公约数
    - D. 最小公共质因子

177. gcd(20,12)的返回值是？
    - A. 20
    - B. 12
    - C. 4
    - D. 2

178. 辗转相除法又称？
    - A. 高斯消元法
    - B. 费马定理
    - C. 欧几里德算法
    - D. 牛顿迭代法

179. 辗转相除法用于求两个整数的最大公约数。( )

180. 关于欧几里得算法gcd1和gcd2的说法错误的是？
    - A. gcd1是递归实现
    - B. gcd2是迭代实现
    - C. 大数据时gcd1需较多辅助空间
    - D. 大数据时gcd1执行效率更高

181. 关于gcd0和gcd1的说法错误的是？
    - A. gcd0时间复杂度O(logN)
    - B. gcd1时间复杂度O(N)
    - C. gcd0效率更高
    - D. gcd1的循环应改为i>1

182. 欧几里得算法适用于a大于或小于b。( )

183. 假设gcd()正确，findMusicalPattern(4,6)返回2。( )

184. 质数判定和筛法目的不同：判定判断单个数字，筛法筛选范围内所有质数。( )

185. 判断N是否为素数，不合适的方法是？
    - A. 埃氏筛法
    - B. 线性筛法
    - C. 二分答案
    - D. 枚举法

186. gcd(84,60)的第二步计算的数是？
    - A. 84和60
    - B. 60和24
    - C. 24和12
    - D. 12和0

187. 通讯卫星在通信网络中的作用是？
    - A. 信息过滤
    - B. 信号中继
    - C. 避免攻击
    - D. 数据加密

188. a=38和b=14对模m同余（a≡b mod m），下列哪个m不可能？
    - A. 3
    - B. 4
    - C. 6
    - D. 9

189. 关于欧几里得算法的正确描述是？
    - A. 求最小公倍数
    - B. 求最大公约数
    - C. 求质数
    - D. 求素数

190. 基于函数isDivisibleBy9和isDigitSumDivisibleBy9，可验算"一个数能被9整除则各位数字之和能被9整除"。( )

---

## 十、算法复杂度（20题）

191. isPrimeA和isPrimeB判断素数，时间复杂度说法正确的是？
    - A. isPrimeA() O(N)，isPrimeB() O(logN)，B更优
    - B. isPrimeA() O(N)，isPrimeB() O(√N)，B更优
    - C. isPrimeA() O(√N)，isPrimeB() O(N)，A更优
    - D. isPrimeA() O(logN)，isPrimeB() O(N)，A更优

192. isPrimeA和isPrimeB的时间复杂度说法正确的是？
    - A. 前者O(N/2)，后者O(√N)，前者更优
    - B. 前者O(N/2)，后者O(√N)，后者更优
    - C. 前者O(√N)，后者O(N/2)，前者更优
    - D. 前者O(N)，后者O(√N)，前者更优

193. 归并排序中merge()函数被调用次数为？
    - A. 3
    - B. 1
    - C. 6
    - D. 7

194. 快速排序的时间复杂度与输入是否有序无关，始终O(NlogN)。( )

195. 归并排序时间复杂度与输入是否有序无关，始终O(NlogN)。( )

196. quick_power的时间复杂度是？
    ```cpp
    double quick_power(double x, unsigned n) {
        if (n == 0) return 1;
        if (n == 1) return x;
        return quick_power(x, n/2) * quick_power(x, n/2) * (n&1 ? x : 1);
    }
    ```
    - A. O(logN)
    - B. O(N)
    - C. O(NlogN)
    - D. O(N²)

197. 单链表和双向链表的简单冒泡排序复杂度相同。( )

198. 统计N的因数可通过不超过N/2的循环实现。( )

199. 判断素数代码需修改的是？
    ```cpp
    for (int i=2, ___; ++i) { // 循环条件
        if (num%i == 0) return false;
    }
    ```
    - A. num<2改为num<=2
    - B. 循环条件i*i<num改为i*i<=num
    - C. 循环条件i<=num
    - D. 循环体if(num%i!=0)

200. 埃氏筛最外层循环范围是？
    - A. for(int i=2;i<=n;++i)
    - B. for(int i=1;i<n;++i)
    - C. for(int i=2;i<=sqrt(n);++i)
    - D. for(int i=1;i<=sqrt(n);++i)

201. 排序算法时间复杂度对比，说法正确的是？

202. 线性筛时间复杂度是O(N)。( )

203. 关于sqrt_binary的错误说法是？
    - A. 阶段1找完全平方根
    - B. 阶段2找小数平方根
    - C. check_int处理浮点误差
    - D. 阶段2循环条件导致死循环

204. 归并排序mergeSort调用涉及的算法是？

205. 算法复杂度分析，说法正确的是？

206. 排序数组使偶数在前奇数在后，时间复杂度是？

207. 关于算法复杂度的说法正确的是？

208. isPrimeA() O(N)，isPrimeB() O(√N)，B更优

209. 快速排序中主元素影响时间复杂度

210. 算法复杂度O(logN)对应二分查找

---

## 十一、参考答案

| 题号 | 答案 | 题号 | 答案 | 题号 | 答案 |
|------|------|------|------|------|------|
| 1 | B | 51 | B | 101 | D |
| 2 | A | 52 | C | 102 | B |
| 3 | B | 53 | C | 103 | C |
| 4 | A | 54 | √ | 104 | C |
| 5 | C | 55 | × | 105 | × |
| 6 | √ | 56 | × | 106 | √ |
| 7 | × | 57 | √ | 107 | √ |
| 8 | × | 58 | × | 108 | × |
| 9 | × | 59 | × | 109 | √ |
| 10 | √ | 60 | √ | 110 | B |
| 11 | × | 61 | × | 111 | √ |
| 12 | A | 62 | × | 112 | C |
| 13 | C | 63 | √ | 113 | A |
| 14 | C | 64 | × | 114 | A |
| 15 | D | 65 | × | 115 | A |
| 16 | C | 66 | A | 116 | B |
| 17 | C | 67 | B | 117 | A |
| 18 | B | 68 | D | 118 | √ |
| 19 | √ | 69 | C | 119 | C |
| 20 | C | 70 | D | 120 | √ |
| 21 | A | 71 | D | 121 | B |
| 22 | A | 72 | × | 122 | A |
| 23 | B | 73 | √ | 123 | √ |
| 24 | B | 74 | A | 124 | × |
| 25 | √ | 75 | √ | 125 | √ |
| 26 | C | 76 | B | 126 | × |
| 27 | D | 77 | A | 127 | × |
| 28 | C | 78 | √ | 128 | √ |
| 29 | A | 79 | B | 129 | A |
| 30 | D | 80 | | 130 | A |
| 31 | C | 81 | × | 131 | B |
| 32 | D | 82 | √ | 132 | A |
| 33 | √ | 83 | B | 133 | × |
| 34 | √ | 84 | D | 134 | B |
| 35 | √ | 85 | B | 135 | √ |
| 36 | √ | 86 | √ | 136 | √ |
| 37 | B | 87 | √ | 137 | × |
| 38 | D | 88 | × | 138 | × |
| 39 | C | 89 | × | 139 | × |
| 40 | × | 90 | √ | 140 | × |
| 41 | A | 91 | A | 141 | B |
| 42 | D | 92 | B | 142 | A |
| 43 | × | 93 | D | 143 | √ |
| 44 | C | 94 | A | 144 | √ |
| 45 | D | 95 | C | 145 | √ |
| 46 | √ | 96 | B | 146 | √ |
| 47 | √ | 97 | A | 147 | × |
| 48 | D | 98 | B | 148 | √ |
| 49 | B | 99 | D | 149 | A |
| 50 | B | 100 | B | 150 | D |

（注：其余参考答案请参照官方答案）
