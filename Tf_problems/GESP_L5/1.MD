# GESP C++五级编程题汇总
## 2023年9月
### 编程题1：因数分解
- **问题描述**：每个正整数都可以分解成素数的乘积，例如\(6=2×3\)、\(20=2^2×5\)。给定一个正整数N，按要求输出它的因数分解式。
- **输入描述**：输入第一行包含一个正整数N，约定\(2 ≤ N ≤ 10^{12}\)。
- **输出描述**：输出一行因数分解式，按质因数由小到大排列，乘号用星号`*`表示且左右各空一格；仅当素数出现多次时，合并为指数形式（用上箭头`^`表示，左右不空格）。
- **样例输入1**：6 → 样例输出1：2 * 3
- **样例输入2**：20 → 样例输出2：2^2 * 5
- **样例输入3**：23 → 样例输出3：23
- **参考程序**：
```cpp
#include <iostream>
using namespace std;
int main() {
    long long N = 0;
    cin >> N;
    bool first = true;
    for (long long p = 2; p * p <= N; p++) {
        if (N % p != 0)
            continue;
        int cnt = 0;
        while (N % p == 0) {
            cnt++;
            N /= p;
        }
        if (!first) {
            cout << " * ";
        } else {
            first = false;
        }
        cout << p;
        if (cnt > 1)
            cout << "^" << cnt;
    }
    if (N > 1) {
        if (!first) {
            cout << " * ";
        }
        cout << N;
    }
    cout << endl;
    return 0;
}
```

### 编程题2：巧夺大奖
- **问题描述**：小明参加游戏，有n个时间段和n个小游戏。每个小游戏有完成期限\(T_i\)（需在第\(T_i\)个时间段结束前完成）和奖励\(R_i\)，每个小游戏可在一个时间段内完成。安排每个时间段选择的小游戏，使总奖励最高。
- **输入描述**：第一行含正整数n（\(1 ≤ n ≤ 500\)）；第二行含n个正整数\(T_i\)（\(1 ≤ T_i ≤ n\)）；第三行含n个正整数\(R_i\)（\(1 ≤ R_i ≤ 1000\)）。
- **输出描述**：输出一行整数C，为最高可获得的奖励。
- **样例输入1**：7 → 4 2 4 3 1 4 6 → 70 60 50 40 30 20 10 → 样例输出1：230
- **参考程序**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n = 0;
struct game_t { int T, R; } games[500];
bool game_cmp(game_t x, game_t y) { return x.R > y.R; }
bool arrange[500];
int main() {
    cin >> n;
    for (int i = 0; i < n; i++)
        arrange[i] = false;
    for (int i = 0; i < n; i++)
        cin >> games[i].T;
    for (int i = 0; i < n; i++)
        cin >> games[i].R;
    sort(games, games + n, game_cmp);
    int sum = 0;
    for (int i = 0; i < n; i++) {
        for (int t = games[i].T - 1; t >= 0; t--) {
            if (!arrange[t]) {
                arrange[t] = true;
                sum += games[i].R;
                break;
            }
        }
    }
    cout << sum << endl;
    return 0;
}
```

## 2023年12月
### 编程题1：小杨的幸运数
- **问题描述**：小杨的超级幸运数是≥a的完全平方数，幸运数是超级幸运数的倍数。非幸运数需通过“幸运化”（不断加1）变为幸运数。给定a和N个整数，判断每个数是否为幸运数；若非，输出幸运化后的结果。
- **输入描述**：第一行2个正整数a、N；接下来N行，每行一个正整数x。
- **输出描述**：N行，是幸运数输出“lucky”，否则输出幸运化后的结果。
- **样例输入1**：4 5 → 1 → 3 → 4 → 5 → 9 → 样例输出1：4 → 4 → lucky → 8 → lucky
- **参考程序**：
```cpp
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <map>
#include <iostream>
#include <cmath>
using namespace std;
const int N = 1001 * 1001;
const double eps = 1e-8;
bool is_lucky[N + 5];
int next_lucky[N + 5];
void init() {}
int main() {
    int a, T;
    scanf("%d%d", &a, &T);
    for (int i = 1; i <= N; i++) {
        int t = int(sqrt(i) + eps);
        if (i >= a && t * t == i)
            is_lucky[i] = 1;
        if (!is_lucky[i])
            continue;
        for (int j = i + i; j <= N; j += i)
            is_lucky[j] = 1;
    }
    for (int i = N; i; i--)
        next_lucky[i] = is_lucky[i] ? i : next_lucky[i + 1];
    while (T--) {
        int x;
        scanf("%d", &x);
        if (is_lucky[x])
            cout << "lucky" << endl;
        else
            cout << next_lucky[x] << endl;
    }
    return 0;
}
```

### 编程题2：烹饪问题
- **问题描述**：有N种食材，第i种美味度为\(a_i\)。两种食材的契合度为其美味度的按位与运算（&）结果。找到契合度最高的两种食材，输出该契合度。
- **输入描述**：第一行整数N；第二行N个整数\(a_0,...,a_{N-1}\)（\(0 ≤ a_i ≤ 2^{31}-1\)）。
- **输出描述**：输出一行整数，为最高契合度。
- **样例输入1**：3 → 1 2 3 → 样例输出1：2
- **样例输入2**：5 → 5 6 2 10 13 → 样例输出2：8
- **参考程序**：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<cstring>
using namespace std;
const int MAX_N = int(1e6) + 100;
int a[MAX_N];
int sort(int l, int r, int k) {
    while (l <= r) {
        while ((l <= r) && (a[l] >> k & 1)) l++;
        while ((l <= r) && (!(a[r] >> k & 1))) r--;
        if (l <= r) swap(a[l++], a[r--]);
    }
    return r;
}
int main() {
    int n, j, ans = 0;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for (int i = 31; i >= 0; i--) {
        j = sort(1, n, i);
        if (j >= 2) {
            ans |= 1 << i;
            n = j;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

## 2024年3月
### 编程题1：成绩排序
- **问题描述**：N名同学有语文、数学、英语三科成绩，按规则排序：1.总分高者靠前；2.总分相同则语文+数学总分高者靠前；3.仍相同则语文和数学最高分高者靠前；4.仍相同则并列。按输入顺序输出每位同学的排名，并列者排名相同，后续名次留空。
- **输入描述**：第一行整数N（\(2 ≤ N ≤ 10^4\)）；接下来N行，每行三个非负整数\(c_i, m_i, e_i\)（0≤均≤150）。
- **输出描述**：N行，按输入顺序输出每位同学的排名。
- **样例输入1**：6 → 140 140 150 → 140 149 140 → 148 141 140 → 141 148 140 → 145 145 139 → 0 0 0 → 样例输出1：1 → 3 → 4 → 4 → 2 → 6
- **参考程序**：
```cpp
#include <iostream>
#include <algorithm>
#include <tuple>
using namespace std;
const int MAX_N = 10005;
tuple<int, int, int, int> students[MAX_N];
int main() {
    ios::sync_with_stdio(false);
    int N;
    cin >> N;
    for (int i = 0; i < N; ++i) {
        int c, m, e;
        cin >> c >> m >> e;
        students[i] = make_tuple(c + m + e, c + m, max(c, m), i);
    }
    sort(students, students + N, greater<tuple<int, int, int, int>>());
    int rank[N];
    tuple<int, int, int> last_student = make_tuple(-1, -1, -1);
    int curr_rank;
    for (int i = 0; i < N; ++i) {
        auto curr = make_tuple(get<0>(students[i]), get<1>(students[i]), get<2>(students[i]));
        if (curr != last_student) {
            last_student = curr;
            curr_rank = i + 1;
        }
        rank[get<3>(students[i])] = curr_rank;
    }
    for (int i = 0; i < N; ++i) {
        cout << rank[i] << endl;
    }
    return 0;
}
```

### 编程题2：B-smooth数
- **问题描述**：B-smooth数是指最大质因子不超过B的正整数。给定n和B，求不超过n的B-smooth数的数量。
- **输入描述**：第一行两个正整数n、B（\(1 ≤ n, B ≤ 10^6\)）。
- **输出描述**：输出非负整数，为不超过n的B-smooth数的数量。
- **样例输入1**：10 3 → 样例输出1：7
- **参考程序**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n, B;
    cin >> n >> B;
    assert(1 <= n && n <= 1e6);
    assert(1 <= B && B <= 1e6);
    vector<bool> vis(n + 5, false);
    vector<int> mx_prime_factor(n + 5, 0);
    vector<int> prime;
    mx_prime_factor[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) {
            mx_prime_factor[i] = i;
            prime.push_back(i);
        }
        for (int p : prime) {
            if (1LL * p * i > n)
                break;
            vis[i * p] = 1;
            mx_prime_factor[i * p] = max(mx_prime_factor[i * p], max(mx_prime_factor[i], p));
            if (i % p == 0)
                break;
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans += (mx_prime_factor[i] <= B);
    cout << ans;
    return 0;
}
```

## 2024年6月
### 编程题1：黑白格
- **问题描述**：n行m列的网格图，每个格子为白色（0）或黑色（1）。求至少包含k个黑色格子的最小子矩形的格子数量，不存在则输出0。
- **输入描述**：第一行三个正整数n、m、k（\(1 ≤ n, m ≤ 100\)，\(1 ≤ k ≤ n×m\)）；之后n行，每行一个长度为m的01串。
- **输出描述**：输出满足条件的最小子矩形的格子数量，不存在则输出0。
- **样例输入1**：4 5 5 → 00000 → 01111 → 00011 → 00011 → 样例输出1：6
- **参考程序**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int sum[N][N];
int w[N][N];
int n, m;
int main() {
    int k;
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) {
        string s;
        cin >> s;
        for (int j = 1; j <= m; j++) {
            w[i][j] = s[j - 1] - '0';
            sum[i][j] = sum[i][j - 1] + w[i][j];
        }
    }
    int ans = 0;
    for (int i = 1; i <= m; i++) {
        for (int j = i; j <= m; j++) {
            vector<int> num;
            int now = 0;
            for (int l = 1; l <= n; l++) {
                int tmp = sum[l][j] - sum[l][i - 1];
                now += tmp;
                num.push_back(now);
                if (now >= k) {
                    if (ans == 0)
                        ans = (j - i + 1) * l;
                    else
                        ans = min(ans, (j - i + 1) * l);
                    int L = 1, R = l;
                    while (L < R) {
                        int mid = L + R + 1 >> 1;
                        if (now - num[mid - 1] >= k)
                            L = mid;
                        else
                            R = mid - 1;
                    }
                    if (now - num[L - 1] >= k) {
                        int res = (j - i + 1) * (l - L + 1);
                        if (ans == 0)
                            ans = res;
                        else
                            ans = min(ans, res);
                    }
                }
            }
        }
    }
    cout << ans << "\n";
    return 0;
}
```

### 编程题2：小杨的幸运数字
- **问题描述**：小杨的幸运数字是恰好有两种不同质因子的正整数（如12=2²×3，质因子为2、3，是幸运数字；30=2×3×5，不是）。给定n个正整数，判断每个是否为幸运数字。
- **输入描述**：第一行正整数n（\(1 ≤ n ≤ 10^4\)）；之后n行，每行一个正整数\(a_i\)（\(2 ≤ a_i ≤ 10^6\)）。
- **输出描述**：n行，是幸运数字输出1，否则输出0。
- **样例输入1**：3 → 7 → 12 → 30 → 样例输出1：0 → 1 → 0
- **参考程序**：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<int, int> mp;
const int N = 1e5 + 10;
int calc(int x) {
    set<int> s;
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            s.insert(i);
            while (x % i == 0)
                x /= i;
        }
    }
    if (x != 1)
        s.insert(x);
    return (int)s.size();
}
int main() {
    int a[N];
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        int x = calc(a[i]);
        if (x == 2)
            cout << "1\n";
        else
            cout << "0\n";
    }
    return 0;
}
```

## 2024年9月
### 编程题1：小杨的武器
- **问题描述**：小杨有n种武器，初始熟练度为\(c_i\)，参加m场战斗。每场战斗选择一种武器使用，使用后武器熟练度增加\(a_j\)（\(a_j\)可正可负）。求m场战斗后，武器熟练度的最大值尽可能大的结果。
- **输入描述**：第一行两个正整数n、m（\(1 ≤ n, m ≤ 10^5\)）；第二行n个正整数\(c_i\)（\(-10^4 ≤ c_i ≤ 10^4\)）；第三行m个正整数\(a_j\)（\(-10^4 ≤ a_j ≤ 10^4\)）。
- **输出描述**：输出m场战斗后武器熟练度的最大可能值。
- **样例输入1**：2 2 → 9 9 → 1 -1 → 样例输出1：10
- **参考程序**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int a[N], c[N];
int main() {
    int n, m;
    cin >> n >> m;
    int mx = -10000;
    for (int i = 1; i <= n; ++i) {
        cin >> c[i];
        mx = max(mx, c[i]);
    }
    for (int i = 1; i <= m; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i <= m; ++i) {
        if (n == 1 || a[i] > 0) {
            mx += a[i];
        }
    }
    cout << mx << "\n";
    return 0;
}
```

### 编程题2：挑战怪物
- **问题描述**：怪物血量为h，需将其血量恰好变为0才能击败。攻击方式：1.物理攻击（第i次使用造成\(2^{i-1}\)点伤害）；2.魔法攻击（选择不超过当前血量的质数p造成p点伤害，至多使用一次）。求最少攻击次数，无法击败输出-1。
- **输入描述**：第一行正整数t（\(1 ≤ t ≤ 10\)）；接下来t行，每行正整数h（\(1 ≤ h ≤ 10^5\)）。
- **输出描述**：每组测试用例输出最少攻击次数，无法击败输出-1。
- **样例输入1**：2 → 3 → 6 → 样例输出1：2 → 4
- **参考程序**：
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> prime;
bool is_prime[100010];
void Eratosthenes(int n) {
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= n; ++i)
        is_prime[i] = true;
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            prime.push_back(i);
            if ((long long)i * i > n)
                continue;
            for (int j = i * i; j <= n; j += i)
                is_prime[j] = false;
        }
    }
}
int main() {
    Eratosthenes(100000);
    int t;
    cin >> t;
    while (t--) {
        int x;
        cin >> x;
        int ans = 0;
        int tmp = 1;
        while (1) {
            if (is_prime[x]) {
                ans++;
                break;
            }
            x -= tmp;
            ans++;
            if (x <= 0) {
                if (x < 0)
                    ans = -1;
                break;
            }
            tmp *= 2;
        }
        cout << ans << "\n";
    }
    return 0;
}
```

## 2024年12月
### 编程题1：奇妙数字
- **问题描述**：奇妙数字是指\(x=p^a\)（p为质数，a为正整数）。给定正整数n，构建含m个奇妙数字的集合，满足：集合无重复数字；数字乘积是n的因子。求集合最多包含的奇妙数字个数。
- **输入描述**：第一行正整数n（\(2 ≤ n ≤ 10^{12}\)）。
- **输出描述**：输出满足条件的集合最大元素个数。
- **样例输入1**：128 → 样例输出1：7
- **参考程序**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e5 + 10;
ll calc(ll x) {
    int ans = 0;
    ll tmp = 1;
    while (x >= tmp) {
        ans++;
        x -= tmp;
        tmp++;
    }
    return ans;
}
int main() {
    ll n;
    cin >> n;
    ll ans = 0;
    for (ll i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            int cnt = 0;
            while (n % i == 0) {
                n /= i;
                cnt++;
            }
            ans += calc(cnt);
        }
    }
    if (n != 1) {
        ans += calc(1);
    }
    cout << ans << "\n";
    return 0;
}
```

### 编程题2：武器强化
- **问题描述**：n种武器和m种强化材料，第i种材料适配第\(p_i\)种武器，花费\(c_i\)金币可修改适配武器。希望适配第1种武器的材料数严格大于其他武器，求最少花费。
- **输入描述**：第一行两个正整数n、m（\(1 ≤ n, m ≤ 1000\)）；之后m行，每行两个正整数\(p_i\)、\(c_i\)（\(1 ≤ p_i ≤ n\)，\(1 ≤ c_i ≤ 10^9\)）。
- **输出描述**：输出最少花费。
- **样例输入1**：4 4 → 1 1 → 2 1 → 3 1 → 3 2 → 样例输出1：1
- **参考程序**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n, m;
int cnt[1010];
vector<int> cs[1010];
ll calc(int aim) {
    int cur_cnt = cnt[1];
    ll res = 0;
    vector<int> tmp;
    for (int i = 2; i <= n; i++) {
        int buy = max((int)cs[i].size() - aim + 1, 0);
        for (int j = 0; j < buy; ++j) {
            res += (ll)cs[i][j];
        }
        cur_cnt += buy;
        for (int j = buy; j < cs[i].size(); ++j) {
            tmp.push_back(cs[i][j]);
        }
    }
    sort(tmp.begin(), tmp.end());
    for (int i = 0; i < aim - cur_cnt; i++) {
        res += (ll)tmp[i];
    }
    return res;
}
signed main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int p, c;
        cin >> p >> c;
        cnt[p]++;
        cs[p].push_back(c);
    }
    for (int i = 1; i <= n; i++) {
        sort(cs[i].begin(), cs[i].end());
    }
    ll ans = 1e18;
    for (int i = max(cnt[1], 1); i <= m; ++i) {
        ans = min(ans, calc(i));
    }
    cout << ans << "\n";
    return 0;
}
```

## 2025年3月
### 编程题1：平均分配
- **问题描述**：小A有2n件物品，小B和小C各买n件。第i件物品小B出价\(b_i\)，小C出价\(c_i\)。求小A卖出所有物品的最大收入。
- **输入描述**：第一行正整数n（\(1 ≤ n ≤ 10^5\)）；第二行2n个整数\(b_1,...,b_{2n}\)（\(0 ≤ b_i ≤ 10^9\)）；第三行2n个整数\(c_1,...,c_{2n}\)（\(0 ≤ c_i ≤ 10^9\)）。
- **输出描述**：输出最大收入。
- **样例输入1**：1 → 3 5 → 4 6 → 样例输出1：9
- **参考程序**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n;
long long b[N], c[N], d[N];
long long ans;
int main() {
    scanf("%d", &n);
    assert(1 <= n && n <= 1e5);
    for (int i = 1; i <= 2 * n; i++) {
        scanf("%lld", &b[i]);
        assert(0 <= b[i] && b[i] <= 1e9);
    }
    for (int i = 1; i <= 2 * n; i++) {
        scanf("%lld", &c[i]);
        assert(0 <= c[i] && c[i] <= 1e9);
    }
    ans = 0;
    for (int i = 1; i <= 2 * n; i++) {
        ans += b[i];
        d[i] = c[i] - b[i];
    }
    sort(d + 1, d + 2 * n + 1);
    for (int i = n + 1; i <= 2 * n; i++) {
        ans += d[i];
    }
    printf("%lld\n", ans);
    return 0;
}
```

### 编程题2：原根判断
- **问题描述**：质数p的原根g满足：1. \(1 < g < p\)；2. \(g^{p-1} \mod p = 1\)；3. 任意\(1 ≤ i < p-1\)，\(g^i \mod p ≠ 1\)。给定a和p，判断a是否为p的原根。
- **输入描述**：第一行正整数T（\(1 ≤ T ≤ 20\)）；每组测试数据一行两个正整数a、p（\(3 ≤ p ≤ 10^9\)，\(1 < a < p\)，p为质数）。
- **输出描述**：每组测试数据输出Yes或No。
- **样例输入1**：3 → 3 998244353 → 5 998244353 → 7 998244353 → 样例输出1：Yes → Yes → No
- **参考程序**：
```cpp
#include<cstdio>
using namespace std;
int a, p;
int ans;
int fpw(int b, int e) {
    if (e == 0)
        return 1;
    int r = fpw(b, e >> 1);
    r = 1LL * r * r % p;
    if (e & 1)
        r = 1LL * r * b % p;
    return r;
}
void check(int e) {
    if (fpw(a, e) == 1)
        ans = 0;
}
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &a, &p);
        ans = 1;
        int phi = p - 1, r = phi;
        for (int i = 2; i * i <= phi; i++) {
            if (phi % i == 0) {
                check(phi / i);
                while (r % i == 0)
                    r /= i;
            }
        }
        if (r > 1)
            check(phi / r);
        printf(ans ? "Yes\n" : "No\n");
    }
    return 0;
}
```

## 2025年6月
### 编程题1：奖品兑换
- **问题描述**：小A有n张课堂优秀券和m张作业优秀券，可通过两种方式兑换奖品：1. a张课堂券+ b张作业券；2. b张课堂券+ a张作业券。求最多可兑换的奖品份数。
- **输入描述**：第一行两个正整数n、m（\(1 ≤ n, m ≤ 10^9\)）；第二行两个正整数a、b（\(1 ≤ a, b ≤ 10^4\)）。
- **输出描述**：输出最多可兑换的奖品份数。
- **样例输入1**：8 8 → 2 1 → 样例输出1：5
- **参考程序**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n, m, a, b;
int l, r;
int check(int v) {
    long long x, y, t;
    x = 1LL * v * a;
    y = 1LL * v * b;
    if (y > m) {
        t = (y - m + (b - a) - 1) / (b - a);
        y -= t * (b - a);
        x += t * (b - a);
    }
    return x <= n && y <= m;
}
int main() {
    scanf("%d%d", &n, &m);
    scanf("%d%d", &a, &b);
    if (n > m)
        swap(n, m);
    if (a > b)
        swap(a, b);
    if (a == b) {
        printf("%d\n", n / a);
        return 0;
    }
    l = 0;
    r = n;
    while (l < r) {
        int mid = (l + r + 1) >> 1;
        if (check(mid))
            l = mid;
        else
            r = mid - 1;
    }
    printf("%d\n", r);
    return 0;
}
```

### 编程题2：最大公因数
- **问题描述**：k≥3个正整数的最大公因数定义为\(gcd(c_1,c_2,...,c_k)=gcd(gcd(c_1,...,c_{k-1}),c_k)\)。给定n个正整数和q组询问，每组询问求\(gcd(a_1+i,a_2+i,...,a_n+i)\)（i为询问序号，1≤i≤q）。
- **输入描述**：第一行两个正整数n、q（\(1 ≤ n, q ≤ 10^5\)）；第二行n个正整数\(a_1,...,a_n\)（\(1 ≤ a_i ≤ 1000\)）。
- **输出描述**：q行，每行输出对应询问的最大公因数。
- **样例输入1**：5 3 → 6 9 12 18 30 → 样例输出1：1 → 1 → 3
- **参考程序**：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int n, q, a[N], g;
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
int main() {
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    sort(a + 1, a + n + 1);
    g = 0;
    for (int i = 2; i <= n; i++)
        g = gcd(g, a[i] - a[i - 1]);
    for (int i = 1; i <= q; i++)
        printf("%d\n", gcd(g, a[1] + i));
    return 0;
}
```

## 2025年9月
### 编程题1：数字选取
- **问题描述**：从1~n的整数中选取若干整数，使任意两个不同整数互质（最大公因数为1），最大化选取数量。
- **输入描述**：一行正整数n（\(1 ≤ n ≤ 10^5\)）。
- **输出描述**：输出最大选取数量。
- **样例输入1**：6 → 样例输出1：4
- **样例输入2**：9 → 样例输出2：5
- **参考程序**：
```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
const int N = 1e5 + 5;
int n, p[N], cnt;
bool np[N];
int main() {
    scanf("%d", &n);
    for (int i = 2; i <= n; i++) {
        if (!np[i])
            p[++cnt] = i;
        for (int j = 1; j <= cnt && i * p[j] <= n; j++) {
            np[i * p[j]] = 1;
            if (i % p[j] == 0)
                break;
        }
    }
    printf("%d\n", 1 + cnt);
    return 0;
}
```

### 编程题2：有趣的数字和
- **问题描述**：二进制表示包含奇数个1的正整数是“有趣的”。给定l、r，统计l≤n≤r的有趣整数之和。
- **输入描述**：一行两个正整数l、r（\(1 ≤ l ≤ r ≤ 10^9\)）。
- **输出描述**：输出有趣整数的和（使用long long）。
- **样例输入1**：3 8 → 样例输出1：19
- **参考程序**：
```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
int l, r;
long long ans;
pair<int, long long> cal2(int n, int p) {
    if (n == 0) {
        return {1 - p, 0};
    }
    if (n == 1) {
        return {1, p};
    }
    return {(n + 1) / 2, 1LL * n * (n + 1) / 4};
}
pair<int, long long> cal(int n, int p) {
    if (n <= 1) {
        return cal2(n, p);
    }
    long long x = 1LL << (31 - __builtin_clz(n));
    auto l_res = cal2(x - 1, p);
    auto r_res = cal(n - x, 1 - p);
    return {l_res.first + r_res.first, l_res.second + r_res.second + x * r_res.first};
}
int main() {
    scanf("%d%d", &l, &r);
    ans = cal(r, 1).second - cal(l - 1, 1).second;
    printf("%lld\n", ans);
    return 0;
}
```

## 2025年12月
### 编程题1：数字移动
- **问题描述**：序列包含n个正整数（n为偶数），恰好有n/2对不同正整数（每对各出现两次）。每次操作可将第i个数字移动到任意位置，花费为该数字的体力。需使每对相同数字相邻，且每次花费不超过X，求最小的X。
- **输入描述**：第一行正整数n（偶数，\(1 ≤ n ≤ 10^5\)）；第二行n个正整数\(A_i\)（\(1 ≤ A_i ≤ 10^5\)），保证至少需一次操作。
- **输出描述**：输出最小的X。
- **样例输入1**：6 → 2 1 2 1 3 3 → 样例输出1：2
- **参考程序**：
```cpp
#include <iostream>
using namespace std;
const int N = 100010;
int a[N];
int b[N];
int pos;
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    int left = 1, right = 1e6, ans = 1e6;
    while (left <= right) {
        int mid = (left + right) / 2;
        bool possible = true;
        pos = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > mid) {
                b[pos++] = a[i];
            }
        }
        for (int i = 0; i < pos; i += 2) {
            if (b[i] != b[i + 1]) {
                possible = false;
                break;
            }
        }
        if (possible) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 编程题2：相等序列
- **问题描述**：序列A有N个正整数，可执行两种操作（每次花费1金币）：1.将\(A_i\)变为\(A_i×P\)（P为任意质数）；2.将\(A_i\)变为\(A_i/P\)（P为任意质数，需\(A_i\)能整除P）。使序列所有整数相同，求最少花费。
- **输入描述**：第一行正整数N（\(1 ≤ N ≤ 10^5\)）；第二行N个正整数\(A_i\)（\(1 ≤ A_i ≤ 10^5\)）。
- **输出描述**：输出最少花费。
- **样例输入1**：5 → 10 6 35 105 42 → 样例输出1：8
- **参考程序**：
```cpp
#include <iostream>
using namespace std;
const int N = 100010;
int num[N][20];
int n, a[N];
void calc_prime_factor(int x) {
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            int cnt = 0;
            while (x % i == 0) {
                x /= i;
                cnt++;
            }
            num[i][cnt]++;
        }
    }
    if (x > 1) {
        num[x][1]++;
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        calc_prime_factor(a[i]);
    }
    long long ans = 0;
    for (int i = 2; i < 100001; i++) {
        int pos = 0;
        for (int j = 0; j < 20; j++) {
            pos += num[i][j];
        }
        num[i][0] = n - pos;
        int median_exponent = 0;
        pos = 0;
        for (int j = 0; j < 20; j++) {
            pos += num[i][j];
            if (pos * 2 >= n) {
                median_exponent = j;
                break;
            }
        }
        for (int j = 0; j < 20; j++) {
            ans += (long long)num[i][j] * abs(j - median_exponent);
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```
