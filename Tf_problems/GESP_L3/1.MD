# GESP C++三级全部编程题汇总
## 2023年6月
### 1. 春游
【问题描述】
老师带领同学们春游。已知班上有 N 位同学，每位同学有从0到 N-1 的唯一编号。到了集合时间，老师确认是否所有同学都到达了集合地点，就让同学们报出自己的编号。到达的同学都会报出自己的编号，不会报出别人的编号，但有的同学很顽皮，会多次报出。你能帮老师找出有哪些同学没有到达吗？

【输入描述】
输入包含2行。第一行包含两个整数 N 和 M，表示班级有 N 位同学，同学们共有 M 次报出编号。约定 2 ≤ N，M ≤ 1000。第二行包含 M 个整数，分别为 M 次报出的编号。约定所有编号都在合理范围内。

【输出描述】
输出一行。如果所有同学都到达，则输出 N；否则由小到大输出所有未到达的同学编号，空格分隔。

【样例输入1】
3 3
0 2 1

【样例输出1】
3

【样例输入2】
3 5
0 0 0 0 0

【样例输出2】
1 2

【参考程序】
```cpp
#include <iostream>
using namespace std;
bool arrive[1000];
int main() {
    int n = 0, m = 0;
    cin >> n >> m;
    // 初始化arrive数组为所有同学均未报到
    for (int i = 0; i < n; i++)
        arrive[i] = false;
    // 依次处理m次报到
    for (int i = 0; i < m; i++) {
        int code = 0;
        cin >> code;
        arrive[code] = true;
    }
    // 依次检查n位同学是否到达
    bool all = true;
    for (int i = 0; i < n; i++) {
        if (!arrive[i]) {
            if (all) {
                cout << i;
                all = false;
            } else {
                cout << " " << i;
            }
        }
    }
    // 处理全部到达的特殊情况
    if (all)
        cout << n;
    cout << endl;
    return 0;
}
```

### 2. 密码合规检测
【问题描述】
网站注册需要有用户名和密码，编写程序以检查用户输入密码的有效性。合规的密码应满足以下要求：
1. 只能由 a-z 之间26个小写字母、A-Z 之间26个大写字母、0-9之间10个数字以及!@#$四个特殊字符构成。
2. 密码最短长度：6个字符，密码最大长度：12个字符。
3. 大写字母、小写字母和数字必须至少有其中两种，以及至少有四个特殊字符中的一个。

【输入描述】
输入一行不含空格的字符串。约定长度不超过100。该字符串被英文逗号分隔为多段，作为多组被检测密码。

【输出描述】
输出若干行，每行输出一组合规的密码。输出顺序以输入先后为序，即先输入则先输出。

【样例输入1】
seHJ12!@,sjdkffH$123,sdf!@&12HDHa!,123&^YUhg@!

【样例输出1】
seHJ12!@
sjdkffH$123

【样例解释1】
输入被英文逗号分为了四组被检测密码：“seHJ12!@”、“sjdkffH$123”、“sdf!@&12HDHa!”、“123&^YUhg@!”。其中，“sdf!@&12HDHa!”长度超过12个字符，不合规；“123&^YUhg@!”包含四个特殊字符之外的字符“^”，不合规。

【参考程序】
```cpp
#include <iostream>
using namespace std;
char line[101]; 
char pwd[101];
// 检查从str开始、长度为l的密码是否合规
bool check(char * str, int l) {
    if (l < 6 || l > 12)
        return false;
    bool hasC = false, hasL = false, hasD = false, hasS = false;
    for (int i = 0; str[i] != '\0'; i++) {
        if ('A' <= str[i] && str[i] <= 'Z') {
            hasC = true;
        } else if ('a' <= str[i] && str[i] <= 'z') {
            hasL = true;
        } else if ('0' <= str[i] && str[i] <= '9') {
            hasD = true;
        } else if (str[i] == '!' || str[i] == '@' ||
                   str[i] == '#' || str[i] == '$') {
            hasS = true;
        } else
            return false;
    }
    if (!hasS)
        return false;
    if (hasC + hasL + hasD < 2)
        return false;
    return true;
}
int main() {
    cin >> line;
    // 按逗号对输入进行切分，并依次判断
    int len = 0;
    for (int i = 0; line[i] != '\0'; i++) {
        if (line[i] != ',') {
            pwd[len] = line[i]; 
            len++;
        } else {
            pwd[len] = '\0';
            if (check(pwd, len))
                cout << pwd << endl;
            len = 0;
        }
    } 
    if (len > 0) {
        pwd[len] = '\0';
        if (check(pwd, len))
            cout << pwd << endl;
    }
    return 0;
}
```

## 2023年9月
### 1. 小杨的储蓄
【问题描述】
小杨共有 N 个储蓄罐，编号从 0 到 N-1。从第 1 天开始，小杨每天都会往存钱罐里存钱。具体来说，第 i 天他会挑选一个存钱罐 a_i，并存入 i 元钱。过了 D 天后，他已经忘记每个储蓄罐里都存了多少钱了，你能帮帮他吗？

【输入描述】
输入 2 行，第一行两个整数 N，D；第二行 D 个整数，其中第 i 个整数为 a_i（保证 0 ≤ a_i ≤ N-1）。每行的各个整数之间用单个空格分隔。保证 1 ≤ N ≤ 1000，1 ≤ D ≤ 1000。

【输出描述】
输出 N 个用单个空格隔开的整数，其中第 i 个整数表示编号为 i 的存钱罐中有多少钱（i=0,1,...,N-1）。

【样例输入1】
3 3
0 1 0

【样例输出1】
4 2 0

【样例解释1】
小杨在第 1 天、第 2 天、第 3 天分别向 0 号、1 号、0 号存钱罐存了 1 元钱、2 元钱、3 元钱，因此 0 号存钱罐有 1+3=4 元钱，1 号存钱罐有 2 元钱，2 号存钱罐有 0 元钱。

【样例输入2】
3 5
0 0 0 2 0

【样例输出2】
11 0 4

【参考程序】
```cpp
#include <iostream>
using namespace std;
int main() { 
    int jar[1000];
    int n = 0, d = 0;
    cin >> n >> d;
    for (int i = 0; i < n; i++)
        jar[i] = 0;
    for (int i = 1; i <= d; i++) {
        int a = 0;
        cin >> a;
        jar[a] += i;
    }
    cout << jar[0];
    for (int i = 1; i < n; i++)
        cout << " " << jar[i];
    cout << endl;
    return 0;
}
```

### 2. 进制判断
【问题描述】
N 进制数指的是逢 N 进一的计数制。例如，人们日常生活中大多使用十进制计数，而计算机底层则一般使用二进制。除此之外，八进制和十六进制在一些场合也是常用的计数制（十六进制中，一般使用字母 A 至 F 表示十至十五）。现在有 N 个数，请你分别判断他们是否可能是二进制、八进制、十进制、十六进制。例如，15A6F 就只可能是十六进制，而 1011 则是四种进制皆有可能。

【输入描述】
输入的第一行为一个十进制表示的整数 N。接下来 N 行，每行一个字符串，表示需要判断的数。保证所有字符串均由数字和大写字母组成，且不以 0 开头。保证不会出现空行。保证 1 ≤ N ≤ 1000，所有字符串长度不超过 10。

【输出描述】
输出 N 行，每行 4 个数，用空格隔开，分别表示给定的字符串是否可能表示一个二进制数、八进制数、十进制数、十六进制数。使用 1 表示可能，使用 0 表示不可能。

【样例输入1】
2
15A6F
1011

【样例输出1】
0 0 0 1
1 1 1 1

【样例输入2】
4
1234567
12345678
FF
GG

【样例输出2】
0 1 1 1
0 0 1 1
0 0 0 1
0 0 0 0

【参考程序】
```cpp
#include <iostream>
using namespace std;
int main() {
    int n = 0;
    cin >> n;
    for (int i = 0; i < n; i++) {
        char str[11];
        cin >> str;
        char max = '0';
        for (int j = 0; str[j] != '\0'; j++)
            if (str[j] > max)
                max = str[j];
        cout << (max <= '1') << " " << (max <= '7') << " " << (max <= '9') << " " << (max <= 'F') << endl;
    }
    return 0;
}
```

## 2023年12月
### 1. 小猫分鱼
【问题描述】
海滩上有一堆鱼，N 只小猫来分。第一只小猫把这堆鱼平均分为 N 份，多了 i 个（i<N），这只小猫把多的 i 个扔入海中，拿走了一份。第二只小猫接着把剩下的鱼平均分成 N 份，又多了 i 个，小猫同样把多的 i 个扔入海中，拿走了一份。第三、第四、……、第 N 只小猫仍是将最终剩下的鱼分成 N 份，扔掉多了的 i 个，并拿走一份。编写程序，输入小猫的数量 N 以及每次扔到海里的鱼的数量 i，输出海滩上最少的鱼数，使得每只小猫都可吃到鱼。

【样例输入1】
2
1

【样例输出1】
7

【样例解释1】
两只小猫来分鱼 N=2，每次扔掉鱼的数量为 i=1，为了每只小猫都可吃到鱼，可令第二只小猫需要拿走1条鱼，则此时待分配的有3条鱼。第一只小猫待分配的鱼有 3×2+1=7 条。

【样例输入2】
3
1

【样例输出2】
25

【样例解释2】
三只小猫来分鱼 N=3，每次扔掉鱼的数量为 i=1，为了每只小猫都可吃到鱼，可令第三只小猫需要拿走3条鱼（拿走1条和2条不满足要求），则此时待分配的有10条鱼。第二只小猫待分配的鱼有 10×3/2+1=16 条。第一只小猫待分配的鱼有 16×3/2+1=25 条。

【输入描述】
总共 2 行。第一行一个整数 N，第二行一个整数 i。保证 0<N<10；i<N。

【输出描述】
一行一个整数，表示满足要求的海滩上最少的鱼数。

【参考程序】
```cpp
#include <stdio.h>
int main(int argc, char **argv)
{
    long long n, i, j, k, ans;
    scanf("%lld%lld", &n, &i);
    bool flag;
    k = 1;
    while(true)
    {
        flag = true;
        ans = k * n + i;
        for(j = 1; j < n; j++)
        {
            if(ans % (n - 1) != 0)
            {
                flag = false;
                break;
            }
            ans = ans / (n - 1) * n + i;
        }
        if(flag) break;
        k++;
    }
    printf("%lld\n", ans);
    return 0;
}
```

### 2. 单位转换
【问题描述】
小杨这周的数学作业是做单位转换，喜欢编程的小杨决定编程帮他解决这些问题。小杨只学了长度单位和重量单位，具体来说：
长度单位包括千米(km)、米(m)、毫米(mm)，它们之间的关系是：1km=1000m=1000000mm
重量单位包括千克(kg)、克(g)、毫克(mg)，它们之间的关系是：1kg=1000g=1000000mg
小杨的作业只涉及将更大的单位转换为更小的单位，也就是说，小杨的作业只会包含如下题型：米转换为毫米，千米转换为毫米，千米转换为米，克转换为毫克，千克转换为毫克，千克转换为克。

【输入描述】
输入的第一行为一个整数 N，表示题目数量。接下来 N 行，每行一个字符串，表示转换单位的题目，格式为 x 单位1 = ? 单位2。其中，x 为一个不超过 1000 的非负整数，单位1 和单位2 分别为两个单位的英文缩写，保证它们都是长度单位或都是重量单位，且单位1 比单位2 更大。保证 1 ≤ N ≤ 1000。

【输出描述】
输出 N 行，依次输出所有题目的答案，输出时，只需要将输入中的 ? 代入答案，其余部分一字不差地输出即可。由于小杨的题目只涉及将更大的单位转换为更小的单位，并且输入的 x 是整数，因此答案一定也是整数。

【样例输入1】
2
1 km = ? mm
1 m = ? mm

【样例输出1】
1 km = 1000000 mm
1 m = 1000 mm

【样例输入2】
5
100 m = ? mm
1000 km = ? m
20 kg = ? g
200 g = ? mg
0 kg = ? mg

【样例输出2】
100 m = 100000 mm
1000 km = 1000000 m
20 kg = 20000 g
200 g = 200000 mg
0 kg = 0 mg

【参考程序】
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int get_base(char *s) { 
    if (strlen(s) == 1)
        return 1000;
    return s[0] == 'k' ? 1000000 : 1;
}
int main() {
    int T;
    scanf("%d", &T); 
    while(T--) {
        int x;
        char s1[5], s2[5];
        scanf("%d", &x);
        scanf("%s", s1);
        scanf("%s", s2); // 读取"="
        scanf("%s", s2); // 读取"?"
        scanf("%s", s2); // 读取单位2
        printf("%d %s = %d %s\n", x, s1, x * get_base(s1) / get_base(s2), s2);
    }
    return 0;
}
```

## 2024年3月
### 1. 字母求和
【问题描述】
小杨同学发明了一种新型密码，对于每一个小写英文字母，该小写字母代表了一个正整数，即该字母在字母顺序中的位置，例如字母 a 代表了正整数 1，字母 b 代表了正整数 2；对于每一个大写英文字母，该大写字母代表了一个负整数，即该字母的 ASCII 码的相反数，例如字母 A 代表了整数 -65。小杨同学利用这种方式对一个整数进行了加密并得到了一个由大写字母和小写字母组成的字符串，该字符串中每个字母所代表数字的总和即为加密前的整数，例如 aAc 对应的加密前的整数为 1+(-65)+3=-61。对于给定的字符串，请你计算出它对应的加密前的整数是多少。

【输入格式】
第一行一个正整数 n，表示字符串中字母的个数。第二行一个由大写字母和小写字母组成的字符串 T，代表加密后得到的字符串。

【输出格式】
输出一行一个整数，代表加密前的整数。

【样例输入1】
3
aAc

【样例输出1】
-61

【数据范围】
对于全部数据，保证有 1 ≤ n ≤ 10^5。

【参考程序】
```cpp
#include <iostream>
#include <assert.h>
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 100005;
char str[N];
int main() {
    int n;
    cin >> n;
    cin >> str;
    assert(n == strlen(str));
    int ans = 0;
    for (int i = 0; i < n; i++) { 
        if (str[i] >= 'a' && str[i] <= 'z')
            ans += str[i] - 'a' + 1;
        else if (str[i] >= 'A' && str[i] <= 'Z')
            ans -= str[i];
        else
            assert(false);
    }
    cout << ans << endl;
    return 0;
}
```

### 2. 完全平方数
【问题描述】
小杨同学有一个包含 n 个非负整数的序列 A，他想要知道其中有多少对下标组合 <<i,j>（1 ≤ i,j ≤n，i<j），使得 A_i + A_j 是完全平方数。如果 x 是完全平方数，则存在非负整数 y 使得 y×y=x。

【输入格式】
第一行一个非负整数 n，表示非负整数个数。第二行包含 n 个非负整数 A_1, A_2, ..., A_n，表示序列 A 包含的非负整数。

【输出格式】
输出一个非负整数，表示和是完全平方数的非负整数对数。

【样例输入1】
5
1 4 3 3 5

【样例输出1】
3

【数据范围】
对于全部数据，保证有 1 ≤n ≤1000，0 ≤A_i ≤10^5。

【参考程序】
```cpp
#include <bits/stdc++.h> 
using namespace std;
const int N = 1010;
int a[N]; 
int main(){
    int n;
    cin >> n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            int m = a[i] + a[j];
            int t = sqrt(m + 1e-7); 
            if(t * t == m)
                ans++;
        }
    }
    cout<<ans<<"\n";
    return 0;
}
```

## 2024年6月
### 1. 移位
【问题描述】
小杨学习了加密技术移位，所有大写字母都向后按照一个固定数目进行偏移。偏移过程会将字母表视作首尾相接的环，例如，当偏移量是3的时候，大写字母 A 会替换成 D，大写字母 Z 会替换成 C，总体来看，大写字母表 ABCDEFGHIJKLMNOPQRSTUVWXYZ 会被替换成 DEFGHIJKLMNOPQRSTUVWXYZABC。注：当偏移量是26的倍数时，每个大写字母经过偏移后会恰好回到原来的位置，即大写字母表 ABCDEFGHIJKLMNOPQRSTUVWXYZ 经过偏移后会保持不变。

【输入格式】
第一行包含一个正整数 n。

【输出格式】
输出在偏移量为 n 的情况下，大写字母表 ABCDEFGHIJKLMNOPQRSTUVWXYZ 移位替换后的结果。

【样例输入1】
3

【样例输出1】
DEFGHIJKLMNOPQRSTUVWXYZABC

【数据范围】
对于全部数据，保证有 1 ≤n ≤100。

【参考程序】
```cpp
#include<bits/stdc++.h>
using namespace std; 
int main(){
    int n;
    cin>>n;
    for(int i=0;i<26;i++){ 
        int j = (i+n)%26;
        char ch = 'A'+j;
        cout<<ch;
    }
    cout<<"\n";
    return 0;
}
```

### 2. 寻找倍数
【问题描述】
小杨有一个包含 n 个正整数的序列 A=[a₁, a₂, …, aₙ]，他想知道是否存在 i(1 ≤i ≤n) 使得 a_i 是序列 A 中所有数的倍数。

【输入格式】
第一行包含一个正整数 t，代表测试用例组数。接下来是 t 组测试用例。对于每组测试用例，一共两行。其中，第一行包含一个正整数 n；第二行包含 n 个正整数，代表序列 A。

【输出格式】
对于每组测试用例，如果存在 i(1 ≤i ≤n) 满足对于所有 k(1 ≤k ≤n)，a_i 是 a_k 的倍数，输出 Yes，否则输出 No。

【样例输入1】
2
3
1 2 4
5
1 2 3 4 5

【样例输出1】
Yes
No

【样例解释1】
对于第一组数据，a₃=4 是 1、2、4 的倍数，因此输出 Yes；第二组数据无满足条件的数，输出 No。

【数据范围】
对于全部数据，保证有 1 ≤t ≤10，1 ≤n ≤10^5，1 ≤a_i ≤10^9。

【参考程序】
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
int a[N];
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int max_val = 0;
        for(int i=1;i<=n;i++){
            cin>>a[i];
            max_val = max(max_val,a[i]);
        }
        int flag = 0;
        for(int i=1;i<=n;i++){
            if(max_val % a[i] != 0){
                flag = 1;
                break;
            }
        }
        if(flag)cout<<"No\n";
        else cout<<"Yes\n";
    }
    return 0;
}
```

## 2024年9月
### 1. 平衡序列
【问题描述】
小杨有一个包含 n 个正整数的序列，他认为一个序列是平衡的当且仅当存在一个正整数 i(1 ≤i<n) 使得序列第 1 个到第 i 个数字的总和等于第 i+1 个到第 n 个数字的总和。小杨想请你判断序列是否是平衡的。

【输入格式】
第一行包含一个正整数 t，代表测试用例组数。接下来是 t 组测试用例。对于每组测试用例，一共两行。第一行包含一个正整数 n，代表序列长度。第二行包含 n 个正整数，代表序列 a。

【输出格式】
对于每组测试用例，如果序列是平衡的，输出 Yes，否则输出 No。

【样例输入1】
3
3
1 2 3
4
2 3 1 4
5
1 2 3 4 5

【样例输出1】
Yes
Yes
No

【样例解释1】
第一组测试用例：i=2 时，1+2=3，平衡；第二组测试用例：i=2 时，2+3=1+4，平衡；第三组无满足条件的 i，不平衡。

【数据范围】
对于全部数据，保证有 1 ≤t ≤100，1 ≤n ≤10000，1 ≤a_i ≤10000。

【参考程序】
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10010];
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int sum=0;
        for(int i=1;i<=n;i++){
            cin>>a[i];
            sum+=a[i];
        }
        int tot=0, flag=0;
        for(int i=1;i<n;i++){
            tot+=a[i];
            if(tot*2==sum){
                flag=1;
                break;
            }
        }
        if(flag)cout<<"Yes\n";
        else cout<<"No\n";
    }
    return 0;
}
```

### 2. 回文拼接
【问题描述】
一个字符串是回文串，当且仅当该字符串从前往后读和从后往前读是一样的。小杨有 n 个仅包含小写字母的字符串，他想请你编写程序判断每个字符串是否由两个长度至少为 2 的回文串前后拼接而成。

【输入格式】
第一行包含一个正整数 n，代表字符串数量。之后 n 行每行一个仅包含小写字母的字符串。

【输出格式】
对于每个字符串输出一行，如果该字符串由两个长度至少为 2 的回文串前后拼接而成则输出 Yes，否则输出 No。

【样例输入1】
4
abcd
aabbb
aaac
abcdd

【样例输出1】
No
Yes
No
No

【样例解释1】
第二个字符串由回文串 "aa" 和 "bbb" 拼接而成，长度均满足至少 2，其余字符串不满足条件。

【数据范围】
对于全部数据，保证有 1 ≤n ≤10，每个字符串的长度不超过 100。

【参考程序】
```cpp
#include<bits/stdc++.h>
using namespace std; 
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        string s;
        cin>>s;
        int m = s.length(); 
        int flag = 0;
        for(int j=2;j<=m-2;j++){ // 分割点j，前半部分长度j，后半部分长度m-j，均≥2
            string s1=s.substr(0,j); 
            string s2=s.substr(j,m-j);
            string t1="",t2="";
            for(int k=(int)s1.size()-1;k>=0;k--)t1+=s1[k]; 
            for(int k=(int)s2.size()-1;k>=0;k--)t2+=s2[k]; 
            if(t1==s1&&t2==s2){
                flag=1; 
                break;
            }
        }
        if(flag)cout<<"Yes\n"; 
        else cout<<"No\n";
    }
    return 0;
}
```

## 2024年12月
### 1. 数字替换
【问题描述】
小杨有一个包含 n 个数字的序列 A，即 A={a₁, a₂, ..., aₙ}，他想将其中大于 k 的数字都替换为序列的最大值，将其中小于 k 的数字都替换为序列的最小值，请你帮他计算出替换后的序列。

【输入格式】
第一行包含两个正整数 n、k，含义如题面所示。第二行包含 n 个数字，代表序列 A。

【输出格式】
输出 n 个整数，代表替换后的结果。

【样例输入1】
10 2
-2 -2 0 2 2 1 5 0 -2 -1

【样例输出1】
-2 -2 -2 2 2 -2 5 -2 -2 -2

【数据范围】
对于全部数据，保证有 1 ≤n ≤10^5，|k|,|a_i| ≤10^5。

【参考程序】
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[100010]; 
int main() { 
    int n, k;
    cin >> n >> k; 
    for (int i = 1; i <=n; i++) { 
        cin >> a[i];
    }
    int max_value = a[1], min_value = a[1];
    for (int i = 1; i <=n; i++) { 
        max_value = max(max_value, a[i]);
        min_value = min(min_value, a[i]);
    }
    for (int i = 1; i <=n; i++) { 
        if (a[i] > k) { 
            a[i] = max_value;
        } else if (a[i] < k) {
            a[i] = min_value;
        }
        if (i != n) { 
            cout << a[i] << " ";
        } else {
            cout << a[i] << endl;
        }
    }
    return 0;
}
```

### 2. 打印数字
【问题描述】
小杨为数字 0、1、2、3 设计了一款表示形式，每个数字占用了 5×5 的网格。数字 0、1、2、3 的表示形式如下（原文描述网格，参考程序中体现）。小杨想请你将给定的数字 n 转换为对应的表示形式。

【输入格式】
第一行包含一个正整数 n，n 仅由数字 0、1、2、3 组成。

【输出格式】
输出对应的表示形式（5 行字符）。

【样例输入1】
12230

【样例输出1】
****.****.****.****..***.
****.****.****.****..***.
.....****.....****..***.
****..****.********..***.
.....****.....****..***.

【数据范围】
对于全部数据，保证有 0 ≤n ≤10^6，且 n 仅由数字 0、1、2、3 组成。

【参考程序】
```cpp
#include <iostream> 
#include <string>
using namespace std;
int main() {
    string n;
    cin >> n;
    for (int row = 0; row < 5; row++) {
        string line = "";
        for (char digit : n) { 
            if (digit == '0') { 
                if (row == 0 || row == 4) {
                    line += ".....";
                } else { 
                    line += ".***.";
                }
            } else if (digit == '1') {
                line += "****.";
            } else if (digit == '2') {
                if (row == 0) {
                    line += ".....";
                } else if (row == 1) { 
                    line += "****.";
                } else if (row == 2) {
                    line += ".....";
                } else if (row == 3) { 
                    line += ".....";
                } else { 
                    line += ".****";
                }
            } else if (digit == '3') {
                if (row == 0) { 
                    line += ".....";
                } else if (row == 1) { 
                    line += "****.";
                } else if (row == 2) {
                    line += ".....";
                } else if (row == 3) { 
                    line += "****.";
                } else {
                    line += ".....";
                }
            }
        }
        cout << line << endl;
    }
    return 0;
}
```

## 2025年3月
### 1. 寻找最小y
【问题描述】
小 A 有一个整数 x，他想找到最小的正整数 y 使得下式成立：(x and y) + (x or y) = 2025。其中 and 表示二进制按位与运算，or 表示二进制按位或运算。如果不存在满足条件的 y，则输出-1。

【输入格式】
一行，一个整数 x。

【输出格式】
一行，一个整数，若满足条件的 y 存在则输出 y，否则输出-1。

【样例输入1】
1025

【样例输出1】
1000

【数据范围】
对于所有测试点，保证 0 ≤x<2025。

【参考程序】
```cpp
#include <cstdio>
using namespace std;
int x;
int main() {
    scanf("%d", &x);
    for (int i = 1; i <= 2025; i++) {
        if ((x & i) + (x | i) == 2025) { 
            printf("%d\n", i);
            return 0;
        }
    }
    printf("-1\n");
    return 0;
}
```

### 2. 词频统计
【问题描述】
在文本处理中，统计单词出现的频率是一个常见的任务。现在，给定 n 个单词，你需要找出其中出现次数最多的单词。在本题中，忽略单词中字母的大小写（即 Apple、apple、APPLE、aPPle 等均视为同一个单词）。请你编写一个程序，输入 n 个单词，输出其中出现次数最多的单词（输出单词为小写形式）。

【输入格式】
第一行，一个整数 n，表示单词的个数；接下来 n 行，每行包含一个单词，单词由大小写英文字母组成。输入保证，出现次数最多的单词只会有一个。

【输出格式】
输出一行，包含出现次数最多的单词（输出单词为小写形式）。

【样例输入1】
6
Apple
banana
apple
Orange
banana
apple

【样例输出1】
apple

【数据范围】
对于所有测试点，1 ≤n ≤100，每个单词的长度不超过 30，且仅由大小写英文字母组成。

【参考程序】
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n; 
    cin >> n; 
    assert(1 <= n && n <= 100);
    map<string, int> cnt;
    int mx = -1;
    for (int i = 1; i <= n; i ++) {
        string s; 
        cin >> s; 
        assert(s.length() <= 30);
        transform(s.begin(), s.end(), s.begin(), ::tolower); 
        if (!cnt.count(s))
            cnt[s] = 0;
        mx = max(mx, ++cnt[s]);
    }
    int mx_num = 0;
    for (auto it = cnt.begin(); it != cnt.end(); it++) {
        if ((it->second) == mx) { 
            cout << (it->first) << '\n';
            mx_num ++;
        }
    }
    assert(mx_num == 1); 
    return 0;
}
```

## 2025年6月
### 1. 奇偶校验
【问题描述】
数据在传输过程中可能出错，因此接收方收到数据后通常会校验传输的数据是否正确，奇偶校验是经典的校验方式之一。给定 n 个非负整数 c₁, c₂, ..., cₙ 代表所传输的数据，它们的校验码取决于这些整数在二进制下 1 的数量之和的奇偶性。如果这些整数在二进制下共有奇数个 1，那么校验码为 1；否则校验码为 0。你能求出这些整数的校验码吗？

【输入格式】
第一行，一个正整数 n，表示所传输的数据量。第二行，n 个非负整数 c₁, c₂, ..., cₙ，表示所传输的数据。

【输出格式】
输出一行，两个整数，以一个空格分隔：第一个整数表示 c₁, c₂, ..., cₙ 在二进制下 1 的总数量；第二个整数表示校验码（0 或 1）。

【样例输入1】
4
71 69 83 80

【样例输出1】
13 1

【样例输入2】
6
1 2 4 8 16 32

【样例输出2】
6 0

【数据范围】
对于所有测试点，保证 1 ≤n ≤100，0 ≤c_i ≤255。

【参考程序】
```cpp
#include <cstdio>
using namespace std;
int n, v = 0;
int main() {
    scanf("%d", &n); 
    for (int i = 1; i <= n; i++) {
        int c;
        scanf("%d", &c);
        while (c) { 
            v += c & 1;
            c >>= 1;
        }
    }
    printf("%d %d\n", v, v & 1); 
    return 0;
}
```

### 2. 分糖果
【问题描述】
有 n 位小朋友排成一队等待老师分糖果。第 i 位小朋友想要至少 a_i 颗糖果，并且分给他的糖果数量必须比分给前一位小朋友的糖果数量更多，不然他就会不开心。老师想知道至少需要准备多少颗糖果才能让所有小朋友都开心？

【输入格式】
第一行，一个正整数 n，表示小朋友的人数。第二行，n 个正整数 a₁, a₂, ..., aₙ，依次表示每位小朋友至少需要的糖果数量。

【输出格式】
输出一行，一个整数，表示最少需要准备的糖果数量。

【样例输入1】
4
1 4 3 3

【样例输出1】
16

【样例输入2】
15
314 15926 53589793 238462643 383279502 8 8 4 1 9 7 1 6 9 3

【样例输出2】
4508143253

【数据范围】
对于所有测试点，保证 1 ≤n ≤1000，1 ≤a_i ≤10^9。

【参考程序】
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1005;
int n, a[N];
long long ans = 0;
int main() { 
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]); 
        if (i > 1)
            a[i] = max(a[i - 1] + 1, a[i]);
        ans += a[i];
    }
    printf("%lld\n", ans);
    return 0;
}
```

## 2025年9月
### 1. 数组清零
【问题描述】
小 A 有一个由 n 个非负整数构成的数组 a=[a₁, a₂, ..., aₙ]。他会对数组 a 重复进行以下操作，直到数组只包含 0。在一次操作中，小 A 会依次完成以下三个步骤：
1. 在数组 a 中找到最大的整数，记其下标为 k。如果有多个最大值，那么选择其中下标最大的。
2. 从数组 a 所有不为零的整数中找到最小的整数 a_j。
3. 将第一步找出的 a_k 减去 a_j。

例如，数组 a=[2,3,4] 需要 7 次操作变成[0,0,0]：[2,3,4]→[2,3,2]→[2,1,2]→[2,1,1]→[1,1,1]→[1,1,0]→[1,0,0]→[0,0,0]

【输入格式】
第一行，一个正整数 n，表示数组 a 的长度。第二行，n 个非负整数 a₁, a₂, ..., aₙ，表示数组 a 中的整数。

【输出格式】
一行，一个正整数，表示 a 中整数全部变成 0 所需要的操作次数。

【样例输入1】
3
2 3 4

【样例输出1】
7

【样例输入2】
5
1 3 2 2 5

【样例输出2】
13

【数据范围】
对于所有测试点，保证 1 ≤n ≤100，0 ≤a_i ≤100。

【参考程序】
```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
const int N = 105;
int n;
int a[N];
int cnt = 0;
int main() { 
    scanf("%d", &n); 
    for (int i = 1; i <= n; i++) 
        scanf("%d", &a[i]);
    while (1) {
        // 找最大值及其最大下标
        int mx_idx = n;
        for (int i = 1; i <= n; i++) {
            if (a[i] >= a[mx_idx]) {
                mx_idx = i;
            }
        }
        if (a[mx_idx] == 0) break; // 所有元素均为0
        // 找非零最小值
        int mn_val = a[mx_idx];
        for (int i = 1; i <= n; i++) {
            if (a[i] > 0 && a[i] < mn_val) {
                mn_val = a[i];
            }
        }
        a[mx_idx] -= mn_val;
        cnt++;
    }
    printf("%d\n", cnt);
    return 0;
}
```

### 2. 日历制作
【问题描述】
小 A 想制作 2025 年每个月的日历。他希望你能编写一个程序，按照格式输出给定月份的日历。具体来说，第一行需要输出 MON TUE WED THU FRI SAT SUN，分别表示星期一到星期日。接下来若干行中依次输出这个月所包含的日期，日期的个位需要和对应星期几的缩写最后一个字母对齐。例如，2025 年 9 月 1 日是星期一，在输出九月的日历时，1 号的个位 1 就需要与星期一 MON 的最后一个字母 N 对齐。

【输入格式】
一行，一个正整数 m，表示需要按照格式输出 2025 年 m 月的日历。

【输出格式】
输出包含若干行，表示 2025 年 m 月的日历。

【样例输入1】
9

【样例输出1】
MON TUE WED THU FRI SAT SUN
  1   2   3   4   5   6   7
  8   9  10  11  12  13  14
 15  16  17  18  19  20  21
 22  23  24  25  26  27  28
 29  30

【样例输入2】
6

【样例输出2】
MON TUE WED THU FRI SAT SUN
                    1
  2   3   4   5   6   7   8
  9  10  11  12  13  14  15
 16  17  18  19  20  21  22
 23  24  25  26  27  28  29
 30

【数据范围】
对于所有测试点，保证 1 ≤m ≤12。

【参考程序】
```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 2025年各月天数
int main(){
    int m;
    scanf("%d", &m);
    printf("MON TUE WED THU FRI SAT SUN\n");
    int total_days = days[m];
    // 计算2025年m月1日是星期几（已知2025年9月1日是周一）
    int week = 1; // 9月1日是周一（1表示周一，7表示周日）
    if (m > 9) {
        for (int i = 9; i < m; i++) {
            week = (week + days[i]) % 7;
            if (week == 0) week = 7;
        }
    } else if (m < 9) {
        for (int i = 8; i >= m; i--) {
            week = (week - 1 + 7) % 7;
            if (week == 0) week = 7;
        }
    }
    // 输出前置空格
    for (int i = 1; i < week; i++) {
        printf("    ");
    }
    // 输出日期
    for (int i = 1; i <= total_days; i++) {
        printf("%3d ", i);
        week++;
        if (week > 7) {
            printf("\n");
            week = 1;
        }
    }
    if (week != 1) printf("\n");
    return 0;
}
```

## 2025年12月
### 1. 密码强度
【问题描述】
小杨是学校网络安全小组的成员，今天他的任务是设计一个“密码强度检测器”，帮助同学们检查自己的密码是否足够安全。一个安全的密码需要满足以下条件：
1. 密码至少包含8个字符。
2. 密码至少包含一个大写字母（A、B、C、...、Z 都可以）。
3. 密码至少包含一个数字（0、1、2、...、9 都可以）。

【输入格式】
第一行一个正整数 T，代表需要安全检测的密码组数。对于每组密码，一行包含一个字符串，代表需要安全检测的密码。

【输出格式】
对于每组密码，输出一行，如果满足强度要求输出 Y，否则输出 N。

【样例输入1】
6
PAs1s2an
1a2bCql3
Pa12bsna
ab1da3cd
Paabdbcd
Pa2

【样例输出1】
Y
Y
Y
N
N
N

【样例解释1】
前三个密码满足所有条件；第四个无大写字母，第五个无数字，第六个长度不足8位，均不满足。

【数据范围】
对于所有测试点，保证 1 ≤T ≤100，每组密码长度不超过 100 且至少为 1，仅由大小写字母和数字组成。

【参考程序】
```cpp
#include <iostream> 
#include <string>
#include <cctype>
using namespace std;
int main() { 
    int T;
    cin >> T; 
    while (T--) { 
        string password;
        cin >> password;
        bool has_upper = false;
        bool has_digit = false;
        for (size_t i = 0; i < password.length(); ++i) {
            if (isupper(password[i])) { 
                has_upper = true;
            }
            if (isdigit(password[i])) {
                has_digit = true;
            }
        }
        if (password.length() >= 8 && has_upper && has_digit) {
            cout << "Y\n";
        } else { 
            cout << "N\n";
        }
    }
    return 0;
}
```

### 2. 小杨的智慧购物
【问题描述】
小杨的班级要举办一个环保手工作品展览，老师请小杨去文具店购买 M 种不同的文具。商店里共有 N 件文具，每件文具都有一个种类编号（从 1 到 M）和价格。小杨的预算有限，他想了一个聪明的办法：对于每种文具，他只买最便宜的那一件（如果同种文具有多件价格相同且都是最便宜的，他只会购买其中的一件）。请你帮小杨计算出，买齐这 M 种文具一共需要花费多少钱。

【输入格式】
第一行两个正整数 M、N，代表文具的种类数和总数。之后 N 行，每行两个正整数 K_i 和 P_i，分别代表第 i 件文具的种类编号和它的价格。数据保证每个种类至少有一件文具可供购买。

【输出格式】
输出一行，代表购买文具的总价。

【样例输入1】
2 5
1 1
1 2
1 1
2 3
2 10

【样例输出1】
4

【样例解释1】
种类 1 最便宜的价格是 1，种类 2 最便宜的价格是 3，总价 1+3=4。

【数据范围】
对于所有测试点，保证 1 ≤M ≤N ≤10^5，1 ≤K_i ≤M，1 ≤P_i ≤10^3。

【参考程序】
```cpp
#include <iostream> 
#include <cstring>
#include <algorithm>
using namespace std; 
int min_price[100005];
int main() {
    int M, N; 
    cin >> M >> N;
    for (int i = 0; i <= M; i++) {
        min_price[i] = 1000000000;
    }
    for (int i = 0; i < N; ++i) {
        int K, P; 
        cin >> K >> P;
        min_price[K] = min(min_price[K], P);
    }
    int total_cost = 0; 
    for (int k = 1; k <= M; ++k) { 
        total_cost += min_price[k];
    }
    cout << total_cost << endl;
    return 0;
}
```