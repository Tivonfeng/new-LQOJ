# C++三级核心考点详解版复习手册

> 基于2023.6-2025.12共11套真题（275题）深度分析
>
> **适用对象**：GESP C++三级考生
> **目标分数**：90分+
>
> ---
>
> **重要说明**：三级是衔接二级的关键过渡，在二级基础上新增以下核心考点
> - 进制转换进阶（二/八/十/十六进制互转）
> - 原码/反码/补码系统
> - 位运算综合应用
> - 字符串高级操作
> - sizeof与数据类型大小
> - 函数参数与返回值

---

## 目录

1. [进制转换](#一进制转换)
2. [原码反码补码](#二原码反码补码)
3. [位运算](#三位运算)
4. [数组操作](#四数组操作)
5. [字符串操作](#五字符串操作)
6. [函数基础](#六函数基础)
7. [数据类型与sizeof](#七数据类型与sizeof)
8. [运算符优先级](#八运算符优先级)
9. [综合应用](#九综合应用)
10. [真题分布统计](#十真题分布统计)

---

## 一、进制转换

### 1.1 进制基本概念

| 进制 | 基数 | 前缀 | 示例 |
|------|------|------|------|
| 二进制 | 2 | 0b | 0b1010 = 10 |
| 八进制 | 8 | 0 | 012 = 10 |
| 十进制 | 10 | 无 | 10 |
| 十六进制 | 16 | 0x | 0xA = 10 |

### 1.2 各进制转十进制

```cpp
// 二进制转十进制：位权展开
// 0b1101 = 1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8 + 4 + 0 + 1 = 13

// 八进制转十进制
// 0123 = 1×8² + 2×8¹ + 3×8⁰ = 64 + 16 + 3 = 83

// 十六进制转十进制
// 0x1A3 = 1×16² + A×16¹ + 3×16⁰ = 256 + 160 + 3 = 419
```

### 1.3 十进制转各进制

```cpp
// 方法1：除基取余法
int decimal = 10;
// 转二进制
string bin = "";
int temp = decimal;
while (temp > 0) {
    bin = char('0' + temp % 2) + bin;
    temp /= 2;
}
// bin = "1010"

// C++标准库方法
cout << oct << decimal;    // 八进制输出
cout << hex << decimal;    // 十六进制输出
cout << dec << decimal;    // 十进制输出
```

### 1.4 二进制小数转十进制

```cpp
// 二进制小数位权（从小数点后开始）
// 0.101 = 1×2⁻¹ + 0×2⁻² + 1×2⁻³ = 0.5 + 0 + 0.125 = 0.625

// 整数 + 小数
// 1101.101 = 13 + 0.625 = 13.625
```

**【真题2506-5】** 二进制数1101.101对应的十进制数是？
- A. 13.625 ✅
- B. 12.75
- C. 11.875
- D. 14.5

### 1.5 快速转换技巧

```cpp
// 十六进制一位 = 二进制四位
// 0xA = 1010, 0xF = 1111

// 八进制一位 = 二进制三位
// 07 = 111, 03 = 011
```

---

## 二、原码反码补码

### 2.1 有符号数的三种表示

```cpp
// 以8位为例，表示范围：-128 ~ 127

// 原码：符号位 + 绝对值的二进制
// +5  = 00000101
// -5  = 10000101

// 反码：正数不变，负数符号位不变，其余取反
// +5  = 00000101
// -5  = 11111010

// 补码：正数不变，负数反码+1
// +5  = 00000101
// -5  = 11111011
```

### 2.2 补码的核心价值

**补码使加减法统一**：计算机只需一种电路（加法器）即可完成加减运算

```cpp
// 7 - 5 = 7 + (-5)
// 7      = 00000111
// -5     = 11111011 (补码)
// -----------------------
// 加法：  00000111 + 11111011 = 00000010 = 2 ✅
```

### 2.3 补码的计算规则

```cpp
// 正数：原码 = 反码 = 补码
// 负数：补码 = 反码 + 1 = 原码符号位不变，其余取反后加1

// 快速求负数补码：从右往左扫描，遇到第一个1后，左边全部取反
// +5 = 00000101 → -5 = 11111011
```

### 2.4 补码的范围

```cpp
// n位补码表示范围：-2^(n-1) ~ 2^(n-1) - 1

// 8位：-128 ~ 127
// 16位：-32768 ~ 32767
// 32位：-2147483648 ~ 2147483647

// 注意：原码和反码的0有两种表示（+0和-0），补码只有一种
```

**【真题2506-1】** 8位二进制原码能表示的最小整数是？
- A. -127 ✅（原码范围：-127~127）
- B. -128（补码才有-128）
- C. -255
- D. -256

**【真题2506-2】** 反码表示中，零的表示形式有几种？
- A. 1种
- B. 2种 ✅（+0: 00000000, -0: 11111111）
- C. 8种
- D. 16种

**【真题2506-3】** 补码10111011对应的真值是？
- A. -69 ✅（符号位为1是负数，补码转原码：取反+1 = 01000101 = 69）
- B. -59
- C. -68
- D. -58

---

## 三、位运算

### 3.1 六种位运算符

| 运算符 | 名称 | 说明 | 示例 |
|--------|------|------|------|
| `&` | 按位与 | 全1为1 | 5 & 3 = 1 (0101 & 0011 = 0001) |
| `\|` | 按位或 | 有1为1 | 5 \| 3 = 7 (0101 \| 0011 = 0111) |
| `^` | 按位异或 | 不同为1 | 5 ^ 3 = 6 (0101 ^ 0011 = 0110) |
| `~` | 按位取反 | 0变1，1变0 | ~5 = -6 (取反后需补码解释) |
| `<<` | 左移 | 乘以2^n | 5 << 1 = 10 |
| `>>` | 右移 | 除以2^n（算术右移保留符号） | -5 >> 1 = -3 |

### 3.2 位运算技巧

```cpp
// 判断奇偶：n & 1
// 奇数：n & 1 = 1
// 偶数：n & 1 = 0

// 获取第n位： (num >> n) & 1
// 设置第n位为1：num | (1 << n)
// 设置第n位为0：num & ~(1 << n)
// 翻转第n位：num ^ (1 << n)

// 交换两个数（无需临时变量）
a = a ^ b;
b = a ^ b;  // b = (a^b)^b = a
a = a ^ b;  // a = (a^b)^a = b
```

### 3.3 左移右移的本质

```cpp
// 左移：相当于乘以2的n次方
5 << 2 = 20  // 5 × 4 = 20
// 注意：可能发生溢出

// 右移：相当于除以2的n次方（向下取整）
7 >> 1 = 3   // 7 ÷ 2 = 3.5 → 3
5 >> 1 = 2   // 5 ÷ 2 = 2.5 → 2
-5 >> 1 = -3 // 算术右移，保留符号位
```

**【真题2509-3】** `if (i % 3 == (8>>2))` 中8>>2的值是？
- A. 1 ✅（8 ÷ 4 = 2）
- B. 2
- C. 4
- D. 8

**【真题2506-8】** 二进制数1101 | 1100的结果是？
- A. 1000
- B. 1110 ✅（1101 | 1100 = 1110）
- C. 1010
- D. 1100

### 3.4 位运算优先级

```cpp
// 优先级（从高到低）：
// ~ (按位取反) > << >> (移位) > & > ^ > | (位运算)

// 与算术运算符比较：
// 算术运算(* / %) > 位运算(<< >>) > 比较运算(< >) > 位与(&)
```

**【真题2509-20】** 位运算符&、|、^、~的优先级高于算术运算符+、-、*、/吗？
- A. 正确
- B. 错误 ✅（算术运算符优先级高于位运算符）

---

## 四、数组操作

### 4.1 数组基础

```cpp
// 定义和初始化
int arr[5];              // 未初始化（垃圾值）
int arr[5] = {1, 2, 3}; // 部分初始化，其余为0
int arr[] = {1, 2, 3};  // 长度为3
int arr[5] = {0};       // 全部初始化为0

// 访问
arr[0] = 10;            // 下标从0开始
cout << arr[4];         // 访问第5个元素
```

### 4.2 数组的重要特性

| 特性 | 说明 |
|------|------|
| 连续存储 | 数组元素在内存中连续分配 |
| 下标从0开始 | arr[0]是第一个元素 |
| 编译时大小 | 数组大小在编译时确定 |
| 越界访问 | arr[5]访问第6个元素是未定义行为 |
| 数组名是常量指针 | arr = arr + 1 ❌ 非法 |

**【真题2512-16】** 在C++中，数组名不能改变，数组名不能被赋值。
- A. 正确 ✅（数组名是常量指针）

**【真题2512-6】** 以下代码执行后，输出的结果是？
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int p = arr[1];
cout << (p + 2) << endl;  // 输出 4 ✅（p=2, p+2=4）
```

### 4.3 数组操作常见算法

```cpp
// 数组交换（原地）
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;

// 不使用临时变量的交换（利用异或）
arr[i] ^= arr[j];
arr[j] ^= arr[i];
arr[i] ^= arr[j];
```

**【真题2512-9】** 数组元素交换
- A. {2,1,4,3,6,5} ✅

---

## 五、字符串操作

### 5.1 string类的基本操作

```cpp
#include <string>
using namespace std;

string s = "Hello";

// 获取长度
s.length();  // 返回5
s.size();    // 同length()

// 访问字符
s[0];        // 'H'（可修改）
s.at(0);     // 'H'（带边界检查）

// 追加
s += " World";      // "Hello World"
s.append("!");      // "Hello World!"
```

### 5.2 substr - 子串截取

```cpp
string s = "HelloWorld";

// substr(pos, len)：从pos开始，截取len个字符
s.substr(0, 5);     // "Hello"
s.substr(5);         // "World"（省略len则截取到末尾）
s.substr(3, 3);      // "loW"

// 超出边界时：截取到末尾，不抛异常
s.substr(10, 5);     // ""（空字符串）
```

**【真题2506-17】** string的substr(1, 3)返回从下标1开始的3个字符的子串。
- A. 正确 ✅

**【真题2506-22】** string的substr(2, 10)在字符串长度不足时会抛出异常？
- A. 正确
- B. 错误 ✅（不会抛异常，会截取到末尾）

### 5.3 replace - 字符串替换

```cpp
string s = "HelloWorld";

// replace(pos, len, str)：从pos开始，替换len个字符为str
s.replace(5, 5, "C++");  // "HelloC++"
s.replace(0, 5, "Hi");    // "HiWorld"
```

**【真题2503-13】** 将"HelloWorld"替换为"HelloC++"，应使用？
- A. str.replace(0, 5, "C++");
- B. str.replace(5, 5, "C++"); ✅

### 5.4 insert - 字符串插入

```cpp
string s = "HelloC++";
s.insert(5, "World");     // "HelloWorldC++"
```

**【真题2503-14】** 在"HelloC++"中插入"World"使其变为"HelloC++World"
- A. str.insert(4, "World");
- B. cout << str.substr(5, 5);
- C. str.insert("World"); cout << str.substr(5, 5);
- D. str.insert(5, "World"); ✅

### 5.5 find/rfind - 字符串查找

```cpp
string s = "Gesp Test";

// find：从前向后找
s.find("e");       // 返回2（第一个'e'的位置）
s.find("e", 3);   // 从位置3开始找，返回6
s.find("e", 10);  // 找不到，返回string::npos

// rfind：从后向前找
s.rfind("e");      // 返回6（最后一个'e'的位置）
```

**【真题2506-14】** "Gesp Test".rfind("e")的结果是？
- A. 1
- B. 2 ✅（最后一个'e'在位置2）
- C. 6
- D. 3

### 5.6 字符串比较

```cpp
string s1 = "hello";
string s2 = "hello";
string s3 = "world";

// == 比较内容（不是地址）
s1 == s2;          // true
s1 == s3;          // false

// 与字面量比较
string("hello") == "hello";  // true ✅
```

**【真题2506-19】** string("hello") == "hello"的比较结果为true。
- A. 正确 ✅（string重载了==运算符，比较内容）

**【真题2506-16】** C++中string的==运算符比较的是字符串的内存地址，而非内容？
- A. 正确
- B. 错误 ✅（比较的是内容）

---

## 六、函数基础

### 6.1 函数定义

```cpp
// 标准形式
返回类型 函数名(参数列表) {
    函数体;
    return 返回值;
}

// 示例
int max(int a, int b) {
    if (a > b) return a;
    return b;
}
```

### 6.2 函数参数

```cpp
// 值传递：传入副本，修改不影响原值
void increment(int x) {
    x++;               // 只修改副本
}

// 引用传递：传入原值别名，修改影响原值
void increment(int& x) {
    x++;               // 修改原值
}
```

### 6.3 函数返回值

```cpp
// void：无返回值
void printHello() {
    cout << "Hello";
    // 不能 return 0; 或 return value;
}

// 返回类型自动转换
double f();            // 声明返回double
int main() {
    return f();        // 自动转换为int
}
```

**【真题2512-7】** 关于C++求最小值函数min()的描述，不正确的是？
- A. 函数必须返回一个值
- B. 该函数可以嵌套调用
- C. 调用min(5)是错误的，不能通过编译
- D. 调用min()（不传任何参数）可以通过编译，结果为0 ✅

**【真题2506-25】** 函数声明double f();返回int时，会自动转换为double？
- A. 正确 ✅

---

## 七、数据类型与sizeof

### 7.1 基本数据类型

| 类型 | 大小（常见平台） | 范围 |
|------|-----------------|------|
| char | 1字节 | -128~127 或 0~255 |
| short | 2字节 | -32768~32767 |
| int | 4字节 | -2147483648~2147483647 |
| long | 4/8字节 | 平台相关 |
| long long | 8字节 | -9e18~9e18 |
| float | 4字节 | 约6位有效数字 |
| double | 8字节 | 约15位有效数字 |
| bool | 1字节 | true/false |

### 7.2 sizeof运算符

```cpp
sizeof(char);        // 1字节
sizeof(int);         // 4字节
sizeof(double);     // 8字节
sizeof(arr);        // 数组总大小 = 单个元素大小 × 元素个数

int arr[10];
sizeof(arr);         // 40字节（10 × 4）
```

### 7.3 unsigned类型

```cpp
// 无符号类型：只能表示非负数
unsigned int n;       // 0 ~ 4294967295（32位）
unsigned short n;     // 0 ~ 65535（16位）

// 运算时的自动转换
int a = -5;
unsigned int b = a;   // b = 4294967291（补码解释）
```

**【真题2512-8】** 若unsigned int类型占用2个字节，则其可表示的数据范围是？
- A. 0 ~ 65535 ✅
- B. 0 ~ 65536
- C. -65536 ~ 65535
- D. 0 ~ 32767

### 7.4 字符常量的类型

```cpp
// 注意：字符常量在C++中是int类型！
sizeof('a');         // 4字节（32位系统）或8字节（64位系统）
sizeof(char);        // 1字节（char类型）
```

**【真题2509-16】** sizeof('a')的结果总是1？
- A. 正确
- B. 错误 ✅（字符常量是int类型）

---

## 八、运算符优先级

### 8.1 完整优先级表

| 优先级 | 运算符 | 说明 | 结合性 |
|--------|--------|------|--------|
| 1 | () [] . -> | 函数调用、数组、结构体 | 左到右 |
| 2 | ! ~ ++ -- + - * & sizeof | 单目运算符 | 右到左 |
| 3 | * / % | 乘除取模 | 左到右 |
| 4 | + - | 加减 | 左到右 |
| 5 | << >> | 位移 | 左到右 |
| 6 | < <= > >= | 关系 | 左到右 |
| 7 | == != | 相等 | 左到右 |
| 8 | & | 位与 | 左到右 |
| 9 | ^ | 位异或 | 左到右 |
| 10 | \| | 位或 | 左到右 |
| 11 | && | 逻辑与 | 左到右 |
| 12 | \|\| | 逻辑或 | 左到右 |
| 13 | ?: | 条件 | 右到左 |
| 14 | = += -= *= /= %= | 赋值 | 右到左 |
| 15 | , | 逗号 | 左到右 |

### 8.2 经典陷阱

```cpp
// 陷阱1：比较链
int x = 5, y = 10, z = 15;
int result = x < y < z;  // (5<10)=1, 1<15=1 → true
                         // 不是 "5<x<15" 的意思！

// 陷阱2：&& 与算术运算
int a = 5;
int b = a < 10 && 20;    // (5<10)=1, 1&&20=20 → b=20

// 陷阱3：赋值与比较
if (a = 5) { }           // 赋值，条件永远为真
if (a == 5) { }          // 比较，正确写法
```

### 8.3 自增自减

```cpp
// 前缀：先增后用
int a = 5, b = ++a;  // a=6, b=6

// 后缀：先用后增
int c = 5, d = c++;  // c=6, d=5

// 在表达式中
int i = 5;
int j = i++ + i++;   // 未定义行为！不要这样写
```

**【真题2512-11】**
```cpp
int t = x--;  // t = x的值，x再减1
t -= x;       // t = t - x
// x=10时：t=10, x=9, t = 10-9 = 1
```

---

## 九、综合应用

### 9.1 进制转换综合

**【真题2503-1】** Base64编码将每3字节输入编码为4字节输出，输入字符串长度为10字节，编码后长度是？
- A. 12字节
- B. 13字节
- C. 14字节
- D. 16字节 ✅

**解析**：10 ÷ 3 = 3组余1字节
- 3组 × 4字节 = 12字节
- 剩余1字节 → 需要补2字节填充 → 1 + 2 = 3字节（但Base64用=填充）
- 实际：12 + 4 = 16字节（因为1字节→2字节需填充到4）

### 9.2 位运算综合

**【真题2512-10】** 计算a&b | (c^d)，其中a=3、b=7、c=15、d=4
- A. 11 ✅
- B. 二进制11
- C. 八进制11
- D. 十六进制11

**解析**：
- a = 3 = 0011
- b = 7 = 0111
- c = 15 = 1111
- d = 4 = 0100
- a&b = 0011 = 3
- c^d = 1111 ^ 0100 = 1011 = 11
- 3 | 11 = 11

### 9.3 字符串综合

**【真题2512-15】**
```cpp
string s = "GESP";
for (int i = 0; i < s.length(); i++) {
    s[i] = toupper(s[i] + i);
}
// G(71)+0=71→G, E(69)+1=70→F, S(83)+2=85→U, P(80)+3=83→T
// 结果：HFTR ✅
```

---

## 十、真题分布统计

| 考点 | 2303 | 2309 | 2312 | 2403 | 2406 | 2409 | 2412 | 2503 | 2506 | 2509 | 2512 |
|------|------|------|------|------|------|------|------|------|------|------|------|
| 进制转换 | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| 原码/补码 | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | |
| 位运算 | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| 数组操作 | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| 字符串 | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| 函数基础 | ✓ | ✓ | | ✓ | ✓ | ✓ | ✓ | | ✓ | ✓ | ✓ |
| sizeof | | | | | | ✓ | | | | ✓ | ✓ |
| 运算符优先级 | | | | | | | | | | ✓ | ✓ |

---

## 参考答案

### 第一章 进制转换
1. B（八进制35.6 = 3×8 + 5 + 6/8 = 29.75）

### 第二章 原码反码补码
1. A（-127是原码最小值）
2. B（反码有两种零）
3. A（补码10111011 = -69）

### 第三章 位运算
1. B（位运算优先级低于算术运算）
2. A（正确描述）

### 第四章 数组操作
1. A（数组名是常量指针）
2. B（正确）

### 第五章 字符串操作
1. B（substr正确用法）
2. B（substr不会抛异常）
3. A（==比较内容）
4. B（rfind返回最后一个位置）

### 第六章 函数基础
1. D（min()调用方式）
2. A（自动类型转换）

### 第七章 sizeof
1. B（字符常量是int类型）
2. A（0~65535）

### 第八章 运算符优先级
1. A（1）
2. B（不是"5<x<15"的意思）

---

> **手册版本**：v1.0
> **更新日期**：2026年2月
> **数据来源**：GESP C++三级2023.6-2025.12共11套真题
