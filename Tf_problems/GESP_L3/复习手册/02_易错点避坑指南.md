# C++三级易错点避坑指南

> 基于2023.6-2025.12共11套真题（275题）高频陷阱总结
>
> **适用对象**：GESP C++三级考生
> **目标**：避开常见陷阱，稳定拿高分

---

## 目录

1. [进制转换陷阱](#一进制转换陷阱)
2. [补码相关陷阱](#二补码相关陷阱)
3. [位运算陷阱](#三位运算陷阱)
4. [字符串操作陷阱](#四字符串操作陷阱)
5. [数组操作陷阱](#五数组操作陷阱)
6. [函数相关陷阱](#六函数相关陷阱)
7. [数据类型陷阱](#七数据类型陷阱)
8. [运算符优先级陷阱](#八运算符优先级陷阱)
9. [考场实战技巧](#九考场实战技巧)

---

## 一、进制转换陷阱

### 陷阱1：小数进制的整数部分

```cpp
// ❌ 错误理解
// 认为 1101.101 的整数部分是 1101 = 13
// 但计算时 1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8+4+0+1 = 13 ✅ 正确

// 陷阱：忘记计算整数部分
// 1101.101 = 13 + 0.625 = 13.625
```

**【真题2506-5】** 二进制数1101.101对应的十进制数是13.625
- 整数部分：1101₂ = 13₁₀
- 小数部分：0.101₂ = 0.625₁₀
- 合计：13.625 ✅

---

### 陷阱2：八进制的前缀

```cpp
// C++中八进制以0开头，不是o或O
int a = 012;   // 八进制12 = 十进制10 ✅
int b = 12;    // 十进制12 ❌（不是八进制）
int c = 0o12;  // C++14之前不支持此写法
```

---

### 陷阱3：十六进制的字母大小写

```cpp
// 十六进制字母可以大写或小写
int a = 0x1A;  // 等于 0x1a
int b = 0XFF;  // 0X 也可以
```

---

## 二、补码相关陷阱

### 陷阱1：原码、反码、补码的范围

```cpp
// 8位原码范围：-127 ~ 127
// 8位反码范围：-127 ~ 127（有两种零）
// 8位补码范围：-128 ~ 127（只有一种零）
```

**【真题2506-1】** 8位二进制原码能表示的最小整数是-127（不是-128）

---

### 陷阱2：补码的-128

```cpp
// ❌ 错误：认为-128的原码是10000000
// ✅ 正确：-128在原码/反码中无法表示，只有补码可以
// 8位补码的-128：10000000
```

---

### 陷阱3：负数补码转原码

```cpp
// ❌ 错误：直接去掉符号位
// 补码10111011 → 去掉符号位得0111011 → 59 → -59 ❌

// ✅ 正确：补码转原码 = 补码取反 + 1（或从右扫描法）
// 补码10111011
// 取反：01000100
// 加1：01000101 = 69
// 所以真值是 -69
```

**【真题2506-3】** 补码10111011对应的真值是-69 ✅

---

### 陷阱4：反码的两种零

```cpp
// ❌ 错误：认为反码只有一种零
// ✅ 正确：反码有两种零
// +0：00000000
// -0：11111111
```

**【真题2506-2】** 反码表示中，零的表示形式有2种 ✅

---

## 三、位运算陷阱

### 陷阱1：位运算优先级

```cpp
// ❌ 错误理解
// 5 + 3 * 2 = 16 ❌
// 5 + (3 * 2) = 11 ✅ 乘法优先级高于加法

// ❌ 错误理解
// a & b | c   // 以为先算&再算|
// 正确：(a & b) | c   // &优先级高于|

// 位运算与算术运算的优先级
// 算术运算(* / %) > 位运算(<< >>) > 比较运算 > 位与(&)
```

**【真题2509-20】** 位运算符优先级低于算术运算符 ✅

---

### 陷阱2：移位运算的符号位

```cpp
// ❌ 错误：右移总是除以2取整
int a = -5;
a >> 1;  // 不是 -2，而是 -3（算术右移保留符号位）

// 正数的右移：高位补0
int b = 8;
b >> 1;  // 4（正确）

// 负数的右移：高位补1（算术右移）
int c = -8;
c >> 1;  // -4（正确）
```

---

### 陷阱3：异或交换的陷阱

```cpp
// ❌ 错误：同一个变量交换
a = a ^ a;  // 结果是0 ❌

// ✅ 正确：不同变量
a = a ^ b;
b = a ^ b;  // b = a
a = a ^ b;  // a = b
```

---

### 陷阱4：按位与判断奇偶

```cpp
// ❌ 错误：对负数使用
int x = -3;
x & 1;  // 结果是1（-3是奇数），但有陷阱！
// 在补码表示中：-3 = 11111101
// 最低位确实是1，说明是奇数
// 但要注意：-1 & 1 = 1，-2 & 1 = 0
```

---

## 四、字符串操作陷阱

### 陷阱1：substr的越界处理

```cpp
// ❌ 错误理解：substr越界会抛出异常
string s = "Hello";
s.substr(10, 5);  // 不会抛出异常，返回空字符串

// ✅ 正确：C++的substr会自动截断到末尾
```

**【真题2506-22】** substr在字符串长度不足时不会抛出异常 ✅

---

### 陷阱2：find和rfind的区别

```cpp
string s = "Gesp Test";

// find：从前向后找，返回第一个匹配的位置
s.find("e");  // 返回2（第一个'e'）

// rfind：从后向前找，返回最后一个匹配的位置
s.rfind("e"); // 返回6（最后一个'e'）

// ❌ 错误：认为rfind返回第一个
```

**【真题2506-14】** "Gesp Test".rfind("e") = 2 ✅

---

### 陷阱3：string的==比较

```cpp
// ❌ 错误：认为==比较的是地址
string s1 = "hello";
string s2 = "hello";
string s3 = new string("hello");

// ✅ 正确：string重载了==，比较的是内容
s1 == s2;  // true（内容相同）
s1 == s3;  // true（内容相同）
```

**【真题2506-19】** string("hello") == "hello"为true ✅
**【真题2506-16】** string的==比较的是内容，不是地址 ✅

---

### 陷阱4：字符与字符串的区别

```cpp
// ❌ 错误：用单引号表示字符串
char c = "hello";  // 错误！单引号是字符

char c1 = 'a';      // 正确：单个字符
string s = "a";     // 正确：字符串
```

---

### 陷阱5：rfind下标问题

```cpp
string s = "HelloC++";
// s.rfind("D") = npos
int pos = s.rfind("D");  // 返回string::npos
pos--;  // 未定义行为！
```

---

## 五、数组操作陷阱

### 陷阱1：数组下标越界

```cpp
// ❌ 错误：下标越界
int arr[5] = {1, 2, 3, 4, 5};
cout << arr[5];  // 未定义行为！越界访问
cout << arr[4];  // 正确：访问最后一个元素

// 正确：arr[0] ~ arr[4]
```

---

### 陷阱2：数组大小必须是常量

```cpp
// ❌ 错误：运行时确定数组大小
int n;
cin >> n;
int arr[n];  // C99支持，但C++标准不支持

// ✅ 正确：使用常量或动态数组
const int SIZE = 10;
int arr[SIZE];  // 正确

int* arr = new int[n];  // 动态分配
```

---

### 陷阱3：数组名是常量指针

```cpp
// ❌ 错误：尝试修改数组名
int arr[5] = {1, 2, 3, 4, 5};
arr = arr + 1;  // 编译错误！数组名是常量

// ✅ 正确：使用指针变量
int* p = arr;
p = p + 1;  // 正确
```

**【真题2512-16】** 数组名不能被赋值 ✅

---

### 陷阱4：sizeof与数组

```cpp
int arr[5] = {1, 2, 3, 4, 5};
sizeof(arr);      // 20字节（5 × 4）

void func(int arr[]) {
    sizeof(arr);  // 4字节（指针大小，不是数组大小）
}

// ❌ 错误：在函数内用sizeof求数组大小
```

---

## 六、函数相关陷阱

### 陷阱1：函数参数传递方式

```cpp
// 值传递：副本
void func1(int x) {
    x = 100;  // 修改副本，不影响原值
}

// 引用传递：原值别名
void func2(int& x) {
    x = 100;  // 修改原值
}
```

---

### 陷阱2：函数返回值类型

```cpp
// ❌ 错误：void函数返回值
void print() {
    cout << "Hello";
    return 0;  // 错误！void不能返回值
}

// ✅ 正确：不return或return;
```

---

### 陷阱3：函数声明与定义

```cpp
// 声明（可以多次）
int max(int a, int b);

// 定义（只能一次）
int max(int a, int b) {
    return a > b ? a : b;
}
```

---

### 陷阱4：main函数的返回

```cpp
// C++标准要求main返回int
int main() {
    // ...
    return 0;  // 成功退出
}
```

---

## 七、数据类型陷阱

### 陷阱1：字符常量是int类型

```cpp
// ❌ 错误：认为sizeof('a') == 1
sizeof('a');      // 4字节（32位系统），因为字符常量是int
sizeof(char);     // 1字节

// ✅ 正确：char类型大小是1，字符常量是int
```

**【真题2509-16】** sizeof('a')不是1 ✅

---

### 陷阱2：unsigned类型的隐式转换

```cpp
int a = -5;
unsigned int b = a;  // b = 4294967291

// ❌ 错误：unsigned不会存储负数
// ✅ 正确：按补码解释，-5的补码是...11111011
// 作为unsigned解释就是大正数
```

---

### 陷阱3：浮点数的精度

```cpp
// ❌ 错误：用==比较浮点数
double x = 0.1 + 0.2;
if (x == 0.3) { }  // 可能不相等！

// ✅ 正确：使用误差范围
const double EPSILON = 1e-9;
if (fabs(x - 0.3) < EPSILON) { }
```

---

### 陷阱4：整数除法的截断

```cpp
// ❌ 错误：认为5/2=2.5
int a = 5;
int b = 2;
double c = a / b;  // 不是2.5，而是2.0！

// ✅ 正确：整数除法截断，或转换类型
double c = double(a) / b;  // 2.5
double c = a / 2.0;        // 2.5
```

**【真题2509-1】** int a=10, b=3; double c = a / b; 结果是3.0（不是3.333...）✅

---

## 八、运算符优先级陷阱

### 陷阱1：比较链

```cpp
// ❌ 错误：认为 x < y < z 是 "x小于y小于z"
int x = 5, y = 10, z = 15;
x < y < z;  // (5<10)=1, 1<15=1 → true
            // 但这和预期不同！

// 如果 x=20, y=10, z=15
// (20<10)=0, 0<15=1 → 仍然是true！
```

---

### 陷阱2：&&与算术运算

```cpp
// ❌ 错误：认为 a < 10 && 20 是 "a<10且a<20"
int a = 5;
a < 10 && 20;  // (5<10)=1, 1&&20=20 → 20（非0为真）

// ✅ 正确：&&优先级高于比较？不，是先比较再&&
// (a < 10) && 20
// 如果a=5：(5<10)=1，1&&20=20（真）
// 如果a=15：(15<10)=0，0&&20=0（假）
```

---

### 陷阱3：赋值与比较

```cpp
// ❌ 错误：if中误用=
if (a = 5) { }  // 永远为真！把5赋给a

// ✅ 正确：比较用==
if (a == 5) { }

// ✅ 高级技巧：常量放前面防止误写
if (5 == a) { }  // 如果写成5=a，编译器报错
```

---

### 陷阱4：三目运算符的优先级

```cpp
// ❌ 错误理解
a > b ? a : b = 10  // 不是 (a>b?a:b) = 10
                   // 而是 a > b ? a : (b = 10)
// 如果a>b，结果为a，然后a = 10
```

---

## 九、考场实战技巧

### 技巧1：遇到难题先跳过

- 先做完有把握的题目
- 回头再处理难题
- 注意时间分配

### 技巧2：善用排除法

- 明显错误的选项先排除
- 缩小选择范围
- 提高正确率

### 技巧3：检查陷阱选项

- 注意"以下全部正确"这类选项
- 包含"绝对"、"总是"的选项要小心
- 检查是否有多选情况

### 技巧4：代码运行结果验证

- 手动模拟代码执行
- 注意边界条件
- 考虑特殊情况

### 技巧5：标记不确定的题目

- 不确定的题目先标记
- 最后有时间再回头检查
- 不要留白

---

## 常见陷阱速查表

| 类别 | 陷阱 | 正确理解 |
|------|------|----------|
| 进制 | 小数进制的整数部分 | 整数和小数分别计算 |
| 补码 | -128的表示 | 只有补码能表示-128 |
| 位运算 | 优先级顺序 | 算术 > 位移 > 比较 > 位与 |
| 字符串 | substr越界 | 不抛异常，返回空串 |
| 数组 | sizeof在函数内 | 得到的是指针大小 |
| 字符 | sizeof('a') | 是int的大小，不是char |
| unsigned | 负数转换 | 按补码解释为大正数 |
| 比较链 | x<y<z | (x<y)的结果再与z比较 |

---

> **手册版本**：v1.0
> **更新日期**：2026年2月
> **数据来源**：GESP C++三级2023.6-2025.12共11套真题
