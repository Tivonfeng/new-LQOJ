# HydroOJ 插件系统 - 跨插件调用指南

## 概述

HydroOJ 基于 Cordis 框架构建插件系统。跨插件调用有以下几种方式：

## 方式一：直接导入（推荐，适用于同一项目中的插件）

如果两个插件在同一个 monorepo 中（如都在 `Tf_plugins/` 目录下），可以直接通过相对路径导入：

```typescript
// 在 exam-hall 插件中导入 score-system 的服务
import { ScoreService } from '../../score-system/src/services/ScoreService';

// 使用
const scoreService = new ScoreService({ enabled: true }, this.ctx);
```

**优点**：
- 简单直接
- TypeScript 类型支持完整
- 编译时检查

**缺点**：
- 需要确保两个插件都在同一项目中
- 如果插件被独立分发，需要处理依赖关系

## 方式二：通过 ctx.provide() 提供服务（推荐用于可复用的服务）

如果服务需要被多个插件使用，应该通过 `ctx.provide()` 提供：

### 1. 在服务提供方（score-system）注册服务

```typescript
// score-system/index.ts
export default async function apply(ctx: Context, config: any = {}) {
    const scoreService = new ScoreService(config, ctx);
    
    // 提供服务给其他插件使用
    ctx.provide('scoreService', scoreService);
    
    // 声明类型扩展
    // ...
}

// 声明模块扩展
declare module 'hydrooj' {
    interface Context {
        scoreService?: ScoreService;
    }
}
```

### 2. 在服务使用方（exam-hall）使用服务

```typescript
// exam-hall/src/handlers/CertificateHandler.ts
async post() {
    // 检查服务是否可用
    if (!this.ctx.scoreService) {
        console.warn('[ExamHall] ScoreService 未加载');
        return;
    }
    
    // 使用服务
    await this.ctx.scoreService.updateUserScore(domainId, uid, score);
}
```

**优点**：
- 解耦，插件可以独立加载
- 运行时检查服务是否可用
- 符合插件系统设计理念

**缺点**：
- 需要确保服务提供方先加载
- 需要处理服务不存在的情况

## 方式三：通过事件系统通信（推荐用于异步操作）

通过事件系统实现插件间的解耦通信：

### 1. 在服务提供方（score-system）监听事件

```typescript
// score-system/index.ts
ctx.on('certificate/created', async (data: { uid: number; weight: number; certificateId: any }) => {
    const scoreService = new ScoreService(config, ctx);
    const scoreToAdd = Math.round(data.weight * 10);
    await scoreService.updateUserScore(domainId, data.uid, scoreToAdd);
});

ctx.on('certificate/deleted', async (data: { uid: number; weight: number; certificateId: any }) => {
    const scoreService = new ScoreService(config, ctx);
    const scoreToDeduct = Math.round(data.weight * 10);
    await scoreService.updateUserScore(domainId, data.uid, -scoreToDeduct);
});
```

### 2. 在服务使用方（exam-hall）触发事件

```typescript
// exam-hall/src/handlers/CertificateHandler.ts
// 创建证书后
ctx.emit('certificate/created', {
    uid: targetUid,
    weight: finalWeight,
    certificateId: certificate._id,
});

// 删除证书前
ctx.emit('certificate/deleted', {
    uid: certificate.uid,
    weight: weight,
    certificateId: certificate._id,
});
```

**优点**：
- 完全解耦，插件之间不需要直接依赖
- 支持多个监听器
- 异步处理，不阻塞主流程

**缺点**：
- 事件名称需要约定
- 需要文档说明事件格式

## 方式四：动态导入（当前实现方式）

使用动态 `import()` 在运行时加载模块：

```typescript
async function getScoreService() {
    try {
        const { ScoreService } = await import('../../../score-system/src/services/ScoreService');
        return ScoreService;
    } catch (err) {
        console.error('[ExamHall] 无法加载 ScoreService:', err);
        return null;
    }
}
```

**优点**：
- 运行时加载，处理模块不存在的情况
- 不阻塞插件加载

**缺点**：
- TypeScript 类型支持较差
- 需要处理加载失败的情况
- 性能略差（运行时加载）

## 推荐方案

对于当前场景（exam-hall 调用 score-system），推荐使用**方式三（事件系统）**：

1. **完全解耦**：exam-hall 和 score-system 互不依赖
2. **可选加载**：即使 score-system 未加载，exam-hall 也能正常工作
3. **易于扩展**：其他插件也可以监听证书事件

**当前实现已采用事件系统** ✅

## 实际应用示例

### 示例：使用事件系统（推荐）

```typescript
// exam-hall/src/handlers/CertificateHandler.ts
// 创建证书后触发事件
ctx.emit('certificate/created', {
    uid: targetUid,
    weight: finalWeight,
    certificateId: certificate._id,
    domainId: this.ctx.domain!._id.toString(),
    certificateName: certificate.certificateName,
});

// score-system/index.ts
// 监听证书创建事件
ctx.on('certificate/created', async (data) => {
    if (!finalConfig.enabled) return;
    
    const scoreService = new ScoreService(finalConfig, ctx);
    const scoreToAdd = Math.round(data.weight * 10);
    
    await scoreService.updateUserScore(data.domainId, data.uid, scoreToAdd);
    await scoreService.addScoreRecord({
        uid: data.uid,
        domainId: data.domainId,
        pid: 0,
        recordId: data.certificateId,
        score: scoreToAdd,
        reason: `获得证书 ${data.certificateName}，权重 ${data.weight}，获得积分 ${scoreToAdd}`,
    });
});
```

这样 exam-hall 和 score-system 完全解耦，score-system 可以选择性地监听证书事件。

